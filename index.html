<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="icon" href="https://raw.githubusercontent.com/english-kunama/translations/main/37.jpg" type="image/png">
    <title>English ↔ Kunama Translation</title>

    <!-- CSS Styles --> 
    <style>
       /* Base styles */
        body {
            font-family: 'Arial', sans-serif;
            background: linear-gradient(135deg, #1e3c72, #2a5298);
            color: white;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            padding: 15px;
            box-sizing: border-box;
            margin: 0;
            transition: background 0.3s ease;
        }

        /* Container styles */
        .container {
            background: white;
            color: #333;
            padding: 20px;
            border-radius: 12px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
            max-width: 90%;
            width: 100%;
            text-align: center;
            position: relative;
            transition: background 0.3s ease, color 0.3s ease, box-shadow 0.3s ease;
        }

        h2, h3 {
            color: #2a5298;
            font-size: 20px;
            margin-bottom: 15px;
            transition: color 0.3s ease;
        }

        /* Form element styles */
        .input-field {
            margin: 10px 0;
            padding: 12px;
            width: 90%;
            border: 2px solid #ccc;
            border-radius: 6px;
            font-size: 16px;
            transition: border 0.3s ease, background 0.3s ease, color 0.3s ease;
        }

        /* Form area */
        #addFormContainer {
            display: none;
            margin-top: 20px;
            padding: 15px;
            background: #f8f8f8;
            border-radius: 8px;
            position: relative;
            transition: background 0.3s ease;
        }

        /* Character Counter */
        .char-counter {
            display: block;
            text-align: right;
            color: #777;
            font-size: 12px;
            margin-top: -8px;
            margin-bottom: 10px;
            padding-right: 5%;
        }

        /* Auto-save indicator */
        .autosave-indicator {
            position: absolute;
            bottom: 10px;
            right: 10px;
            background: rgba(0, 0, 0, 0.1);
            color: #555;
            padding: 3px 8px;
            border-radius: 4px;
            font-size: 12px;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        /* Button styles */
        .button {
            padding: 12px;
            width: 100%;
            margin: 10px 0;
            border: none;
            border-radius: 6px;
            background: linear-gradient(135deg, #6a11cb, #2575fc);
            color: white;
            font-size: 18px;
            cursor: pointer;
            transition: 0.3s;
        }

        .button:hover {
            background: linear-gradient(135deg, #2575fc, #6a11cb);
            transform: translateY(-2px);
        }

        .button-secondary {
            background: linear-gradient(135deg, #808080, #a9a9a9);
        }

        .button-secondary:hover {
            background: linear-gradient(135deg, #a9a9a9, #808080);
        }

        .button-small {
            padding: 8px 15px;
            font-size: 14px;
            width: auto;
        }

        #searchButton {
            display: none;
        }

        /* Results area */
        #results {
            margin-top: 20px;
            text-align: left;
        }

        .result-item {
            margin: 12px 0;
            padding: 15px;
            background: #f0f0f0;
            border-radius: 8px;
            color: #333;
            font-size: 16px;
            display: flex;
            flex-direction: column;
            transition: background 0.3s ease, transform 0.2s ease;
            position: relative;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
        }

        .result-item:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.15);
        }

        .result-content {
            flex: 1;
        }

        .result-actions {
            display: flex;
            justify-content: flex-end;
            margin-top: 10px;
        }

        .copy-button, .tts-button {
            background: none;
            border: none;
            cursor: pointer;
            color: #555;
            font-size: 18px;
            padding: 5px;
            margin-left: 8px;
        }

        .copy-button:hover, .tts-button:hover {
            color: #2575fc;
        }

        /* Modal dialog */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(0, 0, 0, 0.5);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }
        
        .modal-content {
            background: #1c3d2b;
            padding: 20px;
            border-radius: 8px;
            width: 80%;
            max-width: 500px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
            transition: background 0.3s ease, color 0.3s ease;
        }
        
        .confirm-details {
            background: ##5f53e8;
            padding: 10px;
            border-radius: 6px;
            margin: 15px 0;
            text-align: left;
            transition: background 0.3s ease;
        }
        
        .confirm-buttons {
            display: flex;
            justify-content: flex-end;
            gap: 10px;
        }

        /* Search history styles */
        .history-button {
            background: none;
            border: none;
            cursor: pointer;
            font-size: 18px;
            padding: 5px;
            position: absolute;
            right: 20px;
            top: 100px;
        }
        
        .search-history-container {
            position: absolute;
            top: 120px;
            right: 20px;
            background: white;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
            z-index: 10;
            width: 250px;
            max-height: 300px;
            overflow-y: auto;
            text-align: left;
            transition: background 0.3s ease;
        }
        
        .search-history-list {
            list-style: none;
            padding: 0;
            margin: 0;
        }
        
        .history-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 0;
            border-bottom: 1px solid #eee;
        }
        
        .history-text {
            flex: 1;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        
        .history-actions {
            display: flex;
            gap: 5px;
        }
        
        .history-actions button {
            background: none;
            border: none;
            cursor: pointer;
            font-size: 14px;
        }

        /* Recent translations styles */
        .recent-translations-container {
            margin-top: 30px;
            padding: 15px;
            background: #f8f8f8;
            border-radius: 8px;
            text-align: left;
            transition: background 0.3s ease;
        }
        
        .recent-item {
            padding: 10px;
            border-bottom: 1px solid #eee;
            transition: background 0.3s ease;
        }
        
        .recent-item:last-child {
            border-bottom: none;
        }
        
        .recent-date {
            color: #888;
            font-size: 12px;
            display: block;
            margin-top: 5px;
        }

        /* Leaderboard styles */
        .leaderboard-container {
            margin-top: 30px;
            padding: 15px;
            background: #f8f8f8;
            border-radius: 8px;
            text-align: left;
            transition: background 0.3s ease;
        }
        
        .leaderboard-list {
            padding-left: 25px;
        }
        
        .leaderboard-list li {
            margin-bottom: 8px;
            display: flex;
            justify-content: space-between;
        }
        
        .contributor-name {
            font-weight: bold;
        }
        
        .contribution-count {
            color: #666;
        }

        /* Filter styles */
        .search-filter-container {
            margin-top: 10px;
            position: relative;
        }
        
        .filter-toggle {
            background: #f0f0f0;
            border: none;
            border-radius: 4px;
            padding: 8px 12px;
            cursor: pointer;
            font-size: 14px;
            transition: background 0.3s ease;
        }
        
        .filter-toggle:hover {
            background: #e0e0e0;
        }
        
        .filter-options {
            display: none;
            position: absolute;
            left: 0;
            right: 0;
            background: white;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
            z-index: 10;
            margin-top: 10px;
            text-align: left;
            transition: background 0.3s ease;
        }
        
        .filter-group {
            margin-bottom: 12px;
        }
        
        .filter-group label {
            font-weight: bold;
            display: block;
            margin-bottom: 5px;
        }
        
        .filter-group select {
            width: 100%;
            padding: 8px;
            border-radius: 4px;
            border: 1px solid #ccc;
        }
        
        .checkbox-group {
            display: flex;
            gap: 15px;
        }
        
        .checkbox-group label {
            font-weight: normal;
        }
        
        /* Category tags */
        .category-tag {
            display: inline-block;
            background: #e0e0e0;
            color: #555;
            font-size: 12px;
            padding: 3px 8px;
            border-radius: 12px;
            margin-top: 5px;
        }

        /* Pagination styles */
        .pagination-container {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-top: 20px;
            padding: 10px 0;
        }
        
        .page-info {
            color: #666;
            font-size: 14px;
        }
        
        .pagination-buttons {
            display: flex;
            gap: 10px;
        }
        
        .pagination-button {
            background: #f0f0f0;
            border: none;
            padding: 5px 10px;
            border-radius: 4px;
            cursor: pointer;
            transition: background 0.3s ease;
        }
        
        .pagination-button:hover {
            background: #e0e0e0;
        }

        /* Voting system styles */
        .vote-container {
            display: flex;
            align-items: center;
            margin-top: 10px;
            gap: 5px;
        }
        
        .vote-label {
            font-size: 14px;
            color: #666;
        }
        
        .vote-button {
            background: none;
            border: none;
            cursor: pointer;
            font-size: 16px;
            padding: 3px 5px;
            border-radius: 4px;
            transition: background 0.2s ease;
        }
        
        .vote-button:hover {
            background: rgba(0, 0, 0, 0.05);
        }
        
        .vote-count {
            font-size: 12px;
            margin-left: 3px;
        }
        
        .vote-message {
            position: absolute;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 5px 10px;
            border-radius: 4px;
            font-size: 12px;
            bottom: 30px;
            right: 10px;
            animation: fadeInOut 2s forwards;
        }
        
        @keyframes fadeInOut {
            0% { opacity: 0; }
            10% { opacity: 1; }
            90% { opacity: 1; }
            100% { opacity: 0; }
        }

        /* Notification styles */
        .notification {
            position: fixed;
            top: 20px;
            right: 20px;
            padding: 10px 15px;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            border-radius: 6px;
            box-shadow: 0 3px 10px rgba(0, 0, 0, 0.2);
            opacity: 0;
            transform: translateY(-20px);
            transition: all 0.3s ease;
            z-index: 1000;
        }
        
        .notification.success {
            background: rgba(76, 175, 80, 0.9);
        }
        
        .notification.error {
            background: rgba(244, 67, 54, 0.9);
        }
        
        /* Search suggestions */
        .search-suggestions {
            margin-top: 15px;
            background: #f8f8f8;
            padding: 10px;
            border-radius: 6px;
            transition: background 0.3s ease;
        }
        
        .search-suggestions p {
            margin: 0 0 5px 0;
            font-weight: bold;
        }
        
        .search-suggestions ul {
            margin: 0;
            padding-left: 20px;
        }
        
        .search-suggestions a {
            color: #2575fc;
            text-decoration: none;
        }
        
        .search-suggestions a:hover {
            text-decoration: underline;
        }

        /* Dark mode styles */
        .dark-mode-toggle {
            position: absolute;
            top: 15px;
            right: 15px;
            background: none;
            border: none;
            cursor: pointer;
            font-size: 22px;
            color: #555;
            z-index: 5;
        }
        
        body.dark-mode {
            background: linear-gradient(135deg, #1a1a2e, #16213e);
        }
        
        body.dark-mode .container {
            background: #252525;
            color: #e0e0e0;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.4);
        }
        
        body.dark-mode h2, 
        body.dark-mode h3 {
            color: #81a4ff;
        }
        
        body.dark-mode .input-field {
            background: #333;
            color: #e0e0e0;
            border-color: #444;
        }
        
        body.dark-mode .result-item,
        body.dark-mode #addFormContainer,
        body.dark-mode .recent-translations-container,
        body.dark-mode .leaderboard-container,
        body.dark-mode .filter-options,
        body.dark-mode .search-history-container,
        body.dark-mode .modal-content,
        body.dark-mode .search-suggestions,
        body.dark-mode #userProfileSection,
        body.dark-mode #authModal .modal-content {
            background: #333;
            color: #e0e0e0;
        }
        
        body.dark-mode .confirm-details {
            background: #3a3a3a;
        }
        
        body.dark-mode .recent-item {
            border-color: #444;
        }
        
        body.dark-mode .vote-label,
        body.dark-mode .recent-date,
        body.dark-mode .contribution-count,
        body.dark-mode .page-info {
            color: #aaa;
        }
        
        body.dark-mode .filter-toggle,
        body.dark-mode .pagination-button {
            background: #444;
            color: #e0e0e0;
        }
        
        body.dark-mode .filter-toggle:hover,
        body.dark-mode .pagination-button:hover {
            background: #555;
        }
        
        body.dark-mode .category-tag {
            background: #555;
            color: #e0e0e0;
        }
        
        body.dark-mode .history-item {
            border-color: #444;
        }
        
        body.dark-mode .dark-mode-toggle {
            color: #e0e0e0;
        }

        /* User profile styles */
        #userProfileSection {
            margin-top: 20px;
            padding: 15px;
            background: #f8f8f8;
            border-radius: 8px;
            text-align: left;
            transition: background 0.3s ease;
            display: none;
        }
        
        .profile-info {
            display: flex;
            align-items: center;
            margin-bottom: 15px;
        }
        
        .profile-avatar {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            background: #2a5298;
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            margin-right: 15px;
        }
        
        .profile-name {
            font-weight: bold;
            font-size: 18px;
        }
        
        .profile-email {
            color: #666;
            font-size: 14px;
        }
        
        .profile-actions {
            margin-top: 10px;
        }

        /* User menu */
        .user-menu {
            position: absolute;
            top: 15px;
            left: 15px;
            background: none;
            border: none;
            cursor: pointer;
            font-size: 16px;
            color: #2a5298;
            z-index: 5;
            display: flex;
            align-items: center;
            gap: 5px;
            padding: 8px 10px;
            border-radius: 20px;
            background: rgba(255, 255, 255, 0.9);
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
            transition: all 0.3s ease;
        }
        
        .user-menu:hover {
            background: white;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.15);
        }
        
        body.dark-mode .user-menu {
            background: rgba(40, 40, 40, 0.9);
            color: #81a4ff;
        }
        
        body.dark-mode .user-menu:hover {
            background: #333;
        }

        /* Authentication modal */
        #authModal .modal-content {
            max-width: 400px;
        }
        
        .auth-tabs {
            display: flex;
            margin-bottom: 20px;
            border-bottom: 1px solid #ddd;
        }
        
        .auth-tab {
            padding: 10px 15px;
            cursor: pointer;
            margin-right: 5px;
            border-bottom: 2px solid transparent;
        }
        
        .auth-tab.active {
            border-bottom: 2px solid #2a5298;
            font-weight: bold;
            color: #2a5298;
        }
        
        body.dark-mode .auth-tab.active {
            border-color: #81a4ff;
            color: #81a4ff;
        }
        
        .auth-form {
            display: none;
        }
        
        .auth-form.active {
            display: block;
        }
        
        .form-group {
            margin-bottom: 15px;
        }
        
        .form-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
        }
        
        .auth-form .input-field {
            width: 100%;
        }
        
        .auth-switch {
            margin-top: 15px;
            font-size: 14px;
            color: #666;
        }
        
        .auth-switch a {
            color: #2a5298;
            text-decoration: none;
            cursor: pointer;
        }
        
        body.dark-mode .auth-switch {
            color: #aaa;
        }
        
        body.dark-mode .auth-switch a {
            color: #81a4ff;
        }

        /* Contact us link */
        #contactUsLink {
            position: fixed;  
            bottom: 20px;  
            right: 20px;   
            font-size: 14px;  
            color: #fff;  
            background-color: rgba(0, 0, 0, 0.5);  
            padding: 8px 12px;  
            border-radius: 6px;  
            text-decoration: none;  
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);  
            transition: all 0.3s ease;  
        }
        
        #contactUsLink:hover {
            background-color: rgba(0, 0, 0, 0.8);  
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.5);  
        }

        /* Progress bar styles */
        #progressContainer {
            margin-top: 20px;
            text-align: center;
        }
        
        #progressBar {
            height: 20px;
            width: 0%;
            background-color: #4caf50;
            border-radius: 5px;
            transition: width 0.5s ease-in-out;
        }
        
        /* Navigation Bar Styles - NEW */
        .nav-container {
            display: flex;
            justify-content: center;
            margin-bottom: 20px;
            border-bottom: 1px solid #ddd;
            padding-bottom: 10px;
        }
        
        .nav-item {
            padding: 10px 20px;
            cursor: pointer;
            margin: 0 5px;
            border-radius: 6px;
            background: #f0f0f0;
            color: #333;
            transition: all 0.3s ease;
            font-weight: bold;
        }
        
        .nav-item:hover {
            background: #e0e0e0;
            transform: translateY(-2px);
        }
        
        .nav-item.active {
            background: linear-gradient(135deg, #6a11cb, #2575fc);
            color: white;
        }
        
        body.dark-mode .nav-item {
            background: #444;
            color: #e0e0e0;
        }
        
        body.dark-mode .nav-item:hover {
            background: #555;
        }
        
        /* Content sections */
        .content-section {
            display: none;
        }
        
        .content-section.active {
            display: block;
        }
        
        /* Quiz Styles - NEW */
        #quizSection {
            text-align: center;
        }
        
        #quizInfo {
            margin: 20px 0;
        }
        
        #quizLoading {
            display: none;
            margin: 20px 0;
        }
        
        #difficultySelection {
            margin: 15px 0;
            display: flex;
            justify-content: center;
            gap: 10px;
        }
        
        .difficulty-button {
            padding: 8px 15px;
            border: 2px solid #ccc;
            border-radius: 6px;
            background: white;
            color: #333;
            font-size: 16px;
            cursor: pointer;
            transition: 0.3s;
        }
        
        .difficulty-button:hover {
            background: #f0f0f0;
        }
        
        .difficulty-button.selected {
            background: linear-gradient(135deg, #6a11cb, #2575fc);
            color: white;
            border-color: #2575fc;
        }
        
        #questionContainer {
            display: none;
            margin: 20px 0;
            text-align: center;
        }
        
        #quizProgress {
            font-size: 14px;
            color: #666;
            margin-bottom: 10px;
        }
        
        #timerContainer {
            margin: 10px 0;
            font-size: 18px;
            font-weight: bold;
            color: #2a5298;
        }
        
        .timer-warning {
            color: #f44336;
            animation: pulse 1s infinite;
        }
        
        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }
        
        #questionType {
            font-size: 18px;
            color: #2a5298;
            margin-bottom: 5px;
        }
        
        #questionPrompt {
            font-size: 24px;
            font-weight: bold;
            margin-bottom: 20px;
        }
        
        #quizOptions {
            display: flex;
            flex-direction: column;
            gap: 10px;
            margin: 20px 0;
        }
        
        .quiz-option {
            padding: 12px;
            border: 2px solid #ccc;
            border-radius: 6px;
            background: white;
            color: #333;
            font-size: 16px;
            cursor: pointer;
            transition: 0.3s;
            text-align: left;
            position: relative;
            overflow: hidden;
        }
        
        .quiz-option:hover {
            background: #f0f0f0;
            border-color: #999;
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
        }
        
        .quiz-option.correct-answer {
            background-color: #E8F5E9;
            border-color: #4CAF50;
            color: #2E7D32;
            animation: correctAnswer 0.5s;
        }
        
        @keyframes correctAnswer {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }
        
        .quiz-option.wrong-answer {
            background-color: #FFEBEE;
            border-color: #F44336;
            color: #C62828;
            animation: wrongAnswer 0.5s;
        }
        
        @keyframes wrongAnswer {
            0% { transform: translateX(0); }
            25% { transform: translateX(-5px); }
            50% { transform: translateX(5px); }
            75% { transform: translateX(-5px); }
            100% { transform: translateX(0); }
        }
        
        #questionFeedback {
            display: none;
            margin: 10px 0;
            font-size: 18px;
            font-weight: bold;
            padding: 10px;
            border-radius: 6px;
            animation: fadeIn 0.5s;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }
        
        #nextButton {
            display: none;
            margin: 20px auto;
            max-width: 200px;
            transition: all 0.3s;
        }
        
        #nextButton:hover {
            transform: translateX(5px);
        }
        
        #quizFinished {
            display: none;
            margin: 20px 0;
            text-align: center;
            animation: bounceIn 0.7s;
        }
        
        @keyframes bounceIn {
            0% { transform: scale(0.8); opacity: 0; }
            70% { transform: scale(1.05); opacity: 1; }
            100% { transform: scale(1); opacity: 1; }
        }
        
        #quizScore {
            font-size: 30px;
            font-weight: bold;
            margin: 15px 0;
            color: #2a5298;
        }
        
        #quizFeedback {
            font-size: 20px;
            margin: 20px 0;
            padding: 15px;
            background-color: #f5f5f5;
            border-radius: 8px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        
        #streakCounter {
            font-size: 16px;
            margin: 10px 0;
            color: #ff9800;
            font-weight: bold;
        }
        
        #highScoreSection {
            margin: 20px 0;
            padding: 15px;
            background-color: #f0f8ff;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        
        #highScoreValue {
            font-size: 20px;
            font-weight: bold;
            color: #ff9800;
        }
        
        body.dark-mode #quizOptions .quiz-option {
            background: #333;
            color: #e0e0e0;
            border-color: #444;
        }
        
        body.dark-mode #quizOptions .quiz-option:hover {
            background: #444;
            border-color: #555;
        }
        
        body.dark-mode .difficulty-button {
            background: #333;
            color: #e0e0e0;
            border-color: #444;
        }
        
        body.dark-mode .difficulty-button:hover {
            background: #444;
        }
        
        body.dark-mode #highScoreSection,
        body.dark-mode #quizFeedback {
            background-color: #333;
            color: #e0e0e0;
        }
        
        /* Responsive design */
        @media (max-width: 600px) {
            .container {
                padding: 15px;
                max-width: 95%;
            }
            
            .search-history-container {
                width: 200px;
                right: 10px;
            }
            
            .history-button {
                right: 10px;
            }
            
            .filter-options {
                position: fixed;
                left: 5%;
                right: 5%;
                top: 50%;
                transform: translateY(-50%);
            }
            
            .modal-content {
                width: 90%;
            }
            
            #contactUsLink {
                bottom: 10px;
                right: 10px;
            }
            
            .user-menu {
                padding: 5px 8px;
                font-size: 14px;
            }
            
            h2 {
                margin-top: 50px; /* Adds more space at the top to prevent overlap */
                font-size: 18px; /* Slightly smaller font size for mobile */
                padding: 0 10px; /* Adds some horizontal padding */
            }
            
            .nav-container {
                flex-wrap: wrap;
            }
            
            .nav-item {
                padding: 8px 12px;
                font-size: 14px;
                margin-bottom: 5px;
            }
            
            #questionPrompt {
                font-size: 20px;
            }
            
            .quiz-option {
                padding: 10px;
                font-size: 14px;
            }
            
            #quizScore {
                font-size: 24px;
            }
        }
		/* Navigation additions */
    .nav-container {
        position: relative;
    }
    
    .nav-item.has-badge::after {
        content: '';
        position: absolute;
        top: 5px;
        right: 5px;
        width: 10px;
        height: 10px;
        background: #FF5722;
        border-radius: 50%;
        animation: pulse 1.5s infinite;
    }
    
    /* User Stats Panel */
    .user-stats-panel {
        display: flex;
        justify-content: space-around;
        margin: 10px 0 20px;
        padding: 10px;
        background: rgba(255, 255, 255, 0.1);
        border-radius: 10px;
        box-shadow: 0 2px 5px rgba(0,0,0,0.1);
    }
    
    .stats-item {
        text-align: center;
    }
    
    .stats-icon {
        font-size: 24px;
        margin-bottom: 5px;
    }
    
    .stats-value {
        font-size: 22px;
        font-weight: bold;
        color: #2a5298;
    }
    
    .stats-label {
        font-size: 12px;
        color: #666;
    }
    
    body.dark-mode .stats-value {
        color: #81a4ff;
    }
    
    body.dark-mode .stats-label {
        color: #aaa;
    }
    
    /* Daily Challenge Styles */
    .challenge-container {
        margin: 20px 0;
        padding: 15px;
        background: #f8f8f8;
        border-radius: 12px;
        box-shadow: 0 3px 10px rgba(0,0,0,0.1);
        transition: all 0.3s ease;
    }
    
    body.dark-mode .challenge-container {
        background: #333;
    }
    
    .challenge-header {
        display: flex;
        justify-content: space-between;
        margin-bottom: 15px;
        padding-bottom: 10px;
        border-bottom: 1px solid #ddd;
    }
    
    body.dark-mode .challenge-header {
        border-color: #555;
    }
    
    .challenge-day {
        font-weight: bold;
        color: #6a11cb;
    }
    
    .challenge-date {
        color: #666;
    }
    
    body.dark-mode .challenge-day {
        color: #a56eff;
    }
    
    body.dark-mode .challenge-date {
        color: #aaa;
    }
    
    .challenge-card {
        padding: 20px;
        background: white;
        border-radius: 10px;
        box-shadow: 0 2px 8px rgba(0,0,0,0.08);
        margin-bottom: 20px;
    }
    
    body.dark-mode .challenge-card {
        background: #3a3a3a;
    }
    
    .challenge-type {
        font-size: 14px;
        color: #666;
        margin-bottom: 10px;
    }
    
    .challenge-prompt {
        font-size: 20px;
        font-weight: bold;
        margin-bottom: 20px;
    }
    
    .challenge-options {
        display: flex;
        flex-direction: column;
        gap: 10px;
        margin-bottom: 20px;
    }
    
    .challenge-option {
        padding: 12px;
        border: 2px solid #e0e0e0;
        border-radius: 8px;
        background: #f9f9f9;
        cursor: pointer;
        transition: all 0.2s ease;
        text-align: left;
    }
    
    .challenge-option:hover {
        border-color: #2575fc;
        background: #f0f7ff;
        transform: translateY(-2px);
    }
    
    .challenge-option.selected {
        border-color: #2575fc;
        background: #e6f0ff;
    }
    
    .challenge-option.correct {
        border-color: #4CAF50;
        background: #E8F5E9;
    }
    
    .challenge-option.incorrect {
        border-color: #F44336;
        background: #FFEBEE;
    }
    
    body.dark-mode .challenge-option {
        background: #444;
        border-color: #555;
    }
    
    body.dark-mode .challenge-option:hover {
        background: #505050;
        border-color: #81a4ff;
    }
    
    body.dark-mode .challenge-option.selected {
        background: #3a4a6a;
        border-color: #81a4ff;
    }
    
    body.dark-mode .challenge-option.correct {
        background: #1b5e20;
        border-color: #4CAF50;
    }
    
    body.dark-mode .challenge-option.incorrect {
        background: #b71c1c;
        border-color: #F44336;
    }
    
    .challenge-input {
        margin-bottom: 20px;
    }
    
    .challenge-feedback {
        padding: 15px;
        border-radius: 8px;
        margin: 15px 0;
        font-weight: bold;
        transition: all 0.3s ease;
    }
    
    .challenge-feedback.correct {
        background: #E8F5E9;
        color: #2E7D32;
    }
    
    .challenge-feedback.incorrect {
        background: #FFEBEE;
        color: #C62828;
    }
    
    body.dark-mode .challenge-feedback.correct {
        background: #1b5e20;
        color: #E8F5E9;
    }
    
    body.dark-mode .challenge-feedback.incorrect {
        background: #b71c1c;
        color: #FFEBEE;
    }
    
    .challenge-footer {
        display: flex;
        justify-content: space-between;
        margin-top: 20px;
    }
    
    .streak-container, .points-container {
        text-align: center;
    }
    
    .streak-label, .points-label {
        font-size: 12px;
        color: #666;
        margin-bottom: 5px;
    }
    
    .streak-value, .points-value {
        font-size: 18px;
        font-weight: bold;
        color: #2a5298;
    }
    
    body.dark-mode .streak-label, 
    body.dark-mode .points-label {
        color: #aaa;
    }
    
    body.dark-mode .streak-value, 
    body.dark-mode .points-value {
        color: #81a4ff;
    }
    
    .completion-message {
        text-align: center;
        padding: 20px;
        background: #f0f7ff;
        border-radius: 10px;
        margin-bottom: 20px;
    }
    
    body.dark-mode .completion-message {
        background: #3a4a6a;
    }
    
    .achievement-container {
        text-align: center;
        padding: 15px;
        background: #FFF8E1;
        border-radius: 10px;
        margin: 20px 0;
        animation: scaleIn 0.5s ease-out;
    }
    
    body.dark-mode .achievement-container {
        background: #614a19;
    }
    
    @keyframes scaleIn {
        0% { transform: scale(0.8); opacity: 0; }
        100% { transform: scale(1); opacity: 1; }
    }
    
    .achievement {
        display: flex;
        flex-direction: column;
        align-items: center;
    }
    
    .achievement-icon {
        font-size: 40px;
        margin-bottom: 10px;
    }
    
    .achievement-title {
        font-weight: bold;
        margin-bottom: 5px;
    }
    
    .achievement-description {
        font-size: 14px;
        color: #666;
    }
    
    body.dark-mode .achievement-description {
        color: #bbb;
    }
    
    .achievements-section {
        margin-top: 30px;
    }
    
    .achievements-grid {
        display: grid;
        grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
        gap: 15px;
        margin-top: 15px;
    }
    
    .achievement-card {
        padding: 15px;
        border-radius: 10px;
        background: white;
        box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        text-align: center;
        transition: all 0.3s ease;
    }
    
    .achievement-card:hover {
        transform: translateY(-5px);
        box-shadow: 0 5px 15px rgba(0,0,0,0.15);
    }
    
    .achievement-card.locked {
        opacity: 0.5;
        filter: grayscale(1);
    }
    
    body.dark-mode .achievement-card {
        background: #3a3a3a;
    }
    
    /* Enhanced Quiz Styles */
    .quiz-variation-selector {
        margin: 15px 0;
        display: flex;
        flex-wrap: wrap;
        gap: 10px;
        justify-content: center;
    }
    
    .quiz-type-button {
        padding: 10px 15px;
        background: #f0f0f0;
        border: 2px solid #ddd;
        border-radius: 8px;
        cursor: pointer;
        transition: all 0.3s ease;
    }
    
    .quiz-type-button:hover {
        background: #e0e0e0;
        transform: translateY(-2px);
    }
    
    .quiz-type-button.active {
        background: linear-gradient(135deg, #6a11cb, #2575fc);
        color: white;
        border-color: #2575fc;
    }
    
    body.dark-mode .quiz-type-button {
        background: #444;
        border-color: #555;
    }
    
    body.dark-mode .quiz-type-button:hover {
        background: #505050;
    }
    
    /* Sentence Completion Quiz */
    .sentence-completion {
        font-size: 20px;
        margin: 20px 0;
        line-height: 1.6;
    }
    
    .blank-space {
        display: inline-block;
        min-width: 100px;
        border-bottom: 2px solid #2575fc;
        margin: 0 5px;
        padding: 0 5px;
        text-align: center;
    }
    
    /* Image matching quiz */
    .image-container {
        max-width: 250px;
        height: 200px;
        margin: 0 auto 20px;
        border-radius: 10px;
        overflow: hidden;
        box-shadow: 0 4px 10px rgba(0,0,0,0.15);
    }
    
    .quiz-image {
        width: 100%;
        height: 100%;
        object-fit: cover;
    }
    
    /* Listening quiz */
    .listening-controls {
        display: flex;
        justify-content: center;
        margin: 20px 0;
    }
    
    .play-button {
        display: flex;
        align-items: center;
        justify-content: center;
        width: 60px;
        height: 60px;
        border-radius: 50%;
        background: #2575fc;
        color: white;
        font-size: 24px;
        cursor: pointer;
        transition: all 0.3s ease;
        border: none;
    }
    
    .play-button:hover {
        background: #1a66e0;
        transform: scale(1.05);
    }
    
    /* Gamification Styles */
    .level-indicator {
        display: flex;
        align-items: center;
        margin: 10px 0;
        padding: 10px;
        background: #f0f7ff;
        border-radius: 8px;
    }
    
    body.dark-mode .level-indicator {
        background: #3a4a6a;
    }
    
    .level-badge {
        width: 40px;
        height: 40px;
        display: flex;
        align-items: center;
        justify-content: center;
        background: linear-gradient(135deg, #6a11cb, #2575fc);
        color: white;
        border-radius: 50%;
        font-weight: bold;
        margin-right: 15px;
    }
    
    .level-info {
        flex: 1;
    }
    
    .level-title {
        font-weight: bold;
        margin-bottom: 5px;
    }
    
    .level-description {
        font-size: 12px;
        color: #666;
    }
    
    body.dark-mode .level-description {
        color: #aaa;
    }
    
    .progress-container {
        margin-top: 5px;
        width: 100%;
        height: 10px;
        background: #e0e0e0;
        border-radius: 5px;
        overflow: hidden;
    }
    
    .progress-bar {
        height: 100%;
        background: linear-gradient(90deg, #6a11cb, #2575fc);
        border-radius: 5px;
        transition: width 0.5s ease;
    }
    
    body.dark-mode .progress-container {
        background: #555;
    }
    
    /* Word of the Day */
    .word-of-day {
        margin: 20px 0;
        padding: 15px;
        background: #f5f5f5;
        border-radius: 10px;
        text-align: center;
    }
    
    body.dark-mode .word-of-day {
        background: #3a3a3a;
    }
    
    .word-label {
        font-size: 12px;
        color: #666;
        margin-bottom: 5px;
    }
    
    .word-title {
        font-size: 24px;
        font-weight: bold;
        margin-bottom: 10px;
    }
    
    .word-translation {
        font-size: 18px;
        margin-bottom: 10px;
    }
    
    .word-context {
        font-style: italic;
        margin-top: 10px;
        font-size: 14px;
        color: #666;
    }
    
    body.dark-mode .word-label,
    body.dark-mode .word-context {
        color: #aaa;
    }
    
    /* Point Activity Feed */
    .points-activity {
        margin-top: 20px;
    }
    
    .activity-item {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 10px;
        margin-bottom: 10px;
        background: #f9f9f9;
        border-radius: 8px;
        transition: all 0.3s ease;
    }
    
    .activity-item:hover {
        background: #f0f0f0;
    }
    
    body.dark-mode .activity-item {
        background: #3a3a3a;
    }
    
    body.dark-mode .activity-item:hover {
        background: #444;
    }
    
    .activity-description {
        flex: 1;
    }
    
    .activity-points {
        font-weight: bold;
        color: #4CAF50;
    }
    
    .activity-date {
        font-size: 12px;
        color: #888;
    }
    
    body.dark-mode .activity-date {
        color: #aaa;
    }
    
    /* Animation for new features */
    .new-feature {
        position: relative;
    }
    
    .new-feature::after {
        content: 'NEW';
        position: absolute;
        top: -10px;
        right: -10px;
        background: #FF5722;
        color: white;
        font-size: 10px;
        padding: 3px 6px;
        border-radius: 10px;
        font-weight: bold;
    }
    
    /* Responsive adjustments */
    @media (max-width: 600px) {
        .user-stats-panel {
            padding: 5px;
        }
        
        .stats-icon {
            font-size: 20px;
        }
        
        .stats-value {
            font-size: 18px;
        }
        
        .stats-label {
            font-size: 10px;
        }
        
        .challenge-prompt {
            font-size: 18px;
        }
        
        .challenge-footer {
            flex-direction: column;
            gap: 10px;
        }
        
        .achievements-grid {
            grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
        }
        
        .quiz-variation-selector {
            flex-direction: column;
        }
    }
    </style>
</head>

<body>
    <div class="container">
        <!-- User menu button -->
        <button id="userMenuBtn" class="user-menu">
            <span id="userIcon">👤</span>
            <span id="userName">Sign in</span>
        </button>
        
        <h2>🔎 English ↔ Kunama Translation</h2>
        
        <!-- Navigation Bar - NEW -->
        <div class="nav-container">
            <div id="navSearch" class="nav-item active">Search</div>
            <div id="navAdd" class="nav-item">Add New</div>
            <div id="navQuiz" class="nav-item">Games</div>
            <div id="navLeaderboard" class="nav-item">Leaderboard</div>
        </div>
        
        <!-- Search & Results Section -->
        <div id="searchSection" class="content-section active">
            <input type="text" id="searchInput" class="input-field" placeholder="Start typing...">
            <div id="results"></div>
            <div id="statusMessage"></div>
            
            <!-- Progress bar -->
            <div id="progressContainer">
                <p id="progressText">0/5000 submissions needed from users (0%)</p>
                <div style="background-color: #ccc; border-radius: 5px; height: 20px; width: 100%;">
                    <div id="progressBar"></div>
                </div>
            </div>
            
            <!-- Recent translations container -->
            <div id="recentTranslations" class="recent-translations-container">
                <h3>Recently Added</h3>
                <p>Loading recent translations...</p>
            </div>
        </div>
        
        <!-- Add New Section -->
        <div id="addSection" class="content-section">
            <h3>Add New Translation</h3>
            <div>
                <input type="text" id="newPhrase" class="input-field" placeholder="English here...">
                <input type="text" id="newTranslation" class="input-field" placeholder="Kunama here...">
                <select id="newCategory" class="input-field">
                    <option value="">Select category (optional)</option>
                    <option value="greetings">Greetings</option>
                    <option value="food">Food</option>
                    <option value="family">Family</option>
                    <option value="numbers">Numbers</option>
                    <option value="common">Common Phrases</option>
                </select>
                <button id="addPhraseButton" class="button">Add (Itafe)</button>
            </div>
        </div>
        
        <!-- Quiz Section - NEW -->
        <div id="quizSection" class="content-section"><!-- Daily Challenge Section -->
<div id="dailyChallengeSection" class="content-section">
    <h3>Daily Challenge</h3>
    
    <div id="challengeContainer" class="challenge-container">
        <div id="challengeLoading" style="display: none;">
            <p>Loading today's challenge...</p>
        </div>
        
        <div id="challengeContent">
            <div class="challenge-header">
                <div class="challenge-day">Day <span id="challengeStreak">1</span></div>
                <div class="challenge-date" id="challengeDate">April 5, 2025</div>
            </div>
            
            <div class="challenge-card">
                <div class="challenge-type" id="challengeType">Translation Challenge</div>
                <div class="challenge-prompt" id="challengePrompt">How would you say "Hello" in Kunama?</div>
                
                <div id="challengeOptions" class="challenge-options">
                    <!-- Options will be filled dynamically -->
                </div>
                
                <div id="challengeInput" class="challenge-input" style="display: none;">
                    <input type="text" id="userAnswer" class="input-field" placeholder="Type your answer here...">
                </div>
                
                <button id="checkAnswerBtn" class="button">Check Answer</button>
            </div>
            
            <div id="challengeFeedback" class="challenge-feedback" style="display: none;">
                <!-- Feedback will be shown here -->
            </div>
            
            <div class="challenge-footer">
                <div class="streak-container">
                    <div class="streak-label">Current Streak</div>
                    <div class="streak-value"><span id="userStreak">0</span> days</div>
                </div>
                
                <div class="points-container">
                    <div class="points-label">Total Points</div>
                    <div class="points-value"><span id="userPoints">0</span> pts</div>
                </div>
            </div>
        </div>
        
        <div id="challengeComplete" style="display: none;">
            <div class="completion-message">
                <h3>🎉 Challenge Completed!</h3>
                <p>You've completed today's challenge and earned <span id="pointsEarned">10</span> points!</p>
                <p>Come back tomorrow for a new challenge.</p>
            </div>
            
            <div class="achievement-container" id="achievementContainer" style="display: none;">
                <h4>🏆 Achievement Unlocked!</h4>
                <div class="achievement" id="achievementEarned">
                    <!-- Achievement details will be filled here -->
                </div>
            </div>
        </div>
    </div>
    
    <div class="achievements-section">
        <h3>Your Achievements</h3>
        <div class="achievements-grid" id="achievementsGrid">
            <!-- Achievements will be filled dynamically -->
        </div>
    </div>
</div>
            <h3>Test Your Kunama Knowledge</h3>
            
            <div id="quizInfo">
                <p>Test your knowledge of Kunama words and phrases with this interactive quiz!</p>
                
                <div id="difficultySelection">
                    <p>Select difficulty:</p>
                    <button class="difficulty-button" onclick="window.setDifficulty('easy')">Easy</button>
                    <button class="difficulty-button selected" onclick="window.setDifficulty('medium')">Medium</button>
                    <button class="difficulty-button" onclick="window.setDifficulty('hard')">Hard</button>
                </div>
                
                <button id="startQuizButton" onclick="window.startQuiz()" class="button">Start Quiz</button>
            </div>
            
            <div id="quizLoading">
                <p>Loading quiz questions...</p>
            </div>
            
            <div id="questionContainer">
                <div id="quizProgress">Question 1 of 10</div>
                <div id="timerContainer">Time: <span id="timer">15</span>s</div>
                <div id="streakCounter">Current streak: 0</div>
                <div id="questionType">English to Kunama</div>
                <div id="questionPrompt">Translation for: Hello</div>
                
                <div id="quizOptions">
                    <!-- Options will be inserted here -->
                </div>
                
                <div id="questionFeedback"></div>
                <button id="nextButton" onclick="window.nextQuestion()" class="button">Next Question</button>
            </div>
            
            <div id="quizFinished">
                <h3>Quiz Complete!</h3>
                <p>Your score:</p>
                <div id="quizScore">7/10 (70%)</div>
                <div id="quizFeedback">Great job! You're getting very good at Kunama!</div>
                
                <div id="highScoreSection">
                    <p>Your High Score:</p>
                    <div id="highScoreValue">0%</div>
                </div>
                
                <button onclick="window.startQuiz()" class="button">Try Again</button>
            </div>
        </div>
        
        <!-- Leaderboard Section -->
        <div id="leaderboardSection" class="content-section">
            <h3>Top Contributors</h3>
            <div id="contributorLeaderboard" class="leaderboard-container">
                <p>Loading leaderboard...</p>
            </div>
        </div>
		<!-- Daily Challenge Section -->
<div id="dailyChallengeSection" class="content-section">
    <h3>Daily Challenge</h3>
    
    <div id="challengeContainer" class="challenge-container">
        <div id="challengeLoading" style="display: none;">
            <p>Loading today's challenge...</p>
        </div>
        
        <div id="challengeContent">
            <div class="challenge-header">
                <div class="challenge-day">Day <span id="challengeStreak">1</span></div>
                <div class="challenge-date" id="challengeDate">April 5, 2025</div>
            </div>
            
            <div class="challenge-card">
                <div class="challenge-type" id="challengeType">Translation Challenge</div>
                <div class="challenge-prompt" id="challengePrompt">How would you say "Hello" in Kunama?</div>
                
                <div id="challengeOptions" class="challenge-options">
                    <!-- Options will be filled dynamically -->
                </div>
                
                <div id="challengeInput" class="challenge-input" style="display: none;">
                    <input type="text" id="userAnswer" class="input-field" placeholder="Type your answer here...">
                </div>
                
                <button id="checkAnswerBtn" class="button">Check Answer</button>
            </div>
            
            <div id="challengeFeedback" class="challenge-feedback" style="display: none;">
                <!-- Feedback will be shown here -->
            </div>
            
            <div class="challenge-footer">
                <div class="streak-container">
                    <div class="streak-label">Current Streak</div>
                    <div class="streak-value"><span id="userStreak">0</span> days</div>
                </div>
                
                <div class="points-container">
                    <div class="points-label">Total Points</div>
                    <div class="points-value"><span id="userPoints">0</span> pts</div>
                </div>
            </div>
        </div>
        
        <div id="challengeComplete" style="display: none;">
            <div class="completion-message">
                <h3>🎉 Challenge Completed!</h3>
                <p>You've completed today's challenge and earned <span id="pointsEarned">10</span> points!</p>
                <p>Come back tomorrow for a new challenge.</p>
            </div>
            
            <div class="achievement-container" id="achievementContainer" style="display: none;">
                <h4>🏆 Achievement Unlocked!</h4>
                <div class="achievement" id="achievementEarned">
                    <!-- Achievement details will be filled here -->
                </div>
            </div>
        </div>
    </div>
    
    <div class="achievements-section">
        <h3>Your Achievements</h3>
        <div class="achievements-grid" id="achievementsGrid">
            <!-- Achievements will be filled dynamically -->
        </div>
    </div>
</div>
        
        <!-- User profile section -->
        <div id="userProfileSection">
            <h3>Your Profile</h3>
            <div class="profile-info">
                <div class="profile-avatar" id="profileAvatar">?</div>
                <div>
                    <div class="profile-name" id="profileName">Anonymous</div>
                    <div class="profile-email" id="profileEmail"></div>
                </div>
            </div>
            <div class="form-group">
                <label for="displayNameInput">Display Name for Contributions:</label>
                <input type="text" id="displayNameInput" class="input-field" placeholder="Enter your preferred display name">
            </div>
            <div class="profile-actions">
                <button id="saveProfileBtn" class="button">Save Profile</button>
                <button id="signOutBtn" class="button button-secondary">Sign Out</button>
            </div>
        </div>
        
        <!-- The dark mode toggle will be added here by JavaScript -->
    </div>
	<!-- Add this to your HTML as well, just before the closing </div> of the container -->
		<div id="userStats" class="user-stats-panel">
			<div class="stats-item">
				<div class="stats-icon">🔥</div>
				<div class="stats-value" id="statStreak">0</div>
				<div class="stats-label">Day Streak</div>
			</div>
			<div class="stats-item">
				<div class="stats-icon">⭐</div>
				<div class="stats-value" id="statPoints">0</div>
				<div class="stats-label">Points</div>
			</div>
			<div class="stats-item">
				<div class="stats-icon">🏆</div>
				<div class="stats-value" id="statAchievements">0</div>
				<div class="stats-label">Achievements</div>
			</div>
		</div>
    
    <!-- Authentication Modal -->
    <div id="authModal" class="modal-overlay" style="display: none;">
        <div class="modal-content">
            <h3>Sign In or Sign Up</h3>
            <div class="auth-tabs">
                <div class="auth-tab active" data-tab="signin">Sign In</div>
                <div class="auth-tab" data-tab="signup">Sign Up</div>
            </div>
            
            <!-- Sign In Form -->
            <div id="signinForm" class="auth-form active">
                <div class="form-group">
                    <label for="signinEmail">Email:</label>
                    <input type="email" id="signinEmail" class="input-field" placeholder="Enter your email">
                </div>
                <div class="form-group">
                    <label for="signinPassword">Password:</label>
                    <input type="password" id="signinPassword" class="input-field" placeholder="Enter your password">
                </div>
                <button id="signinBtn" class="button">Sign In</button>
                <div class="auth-switch">
                    Don't have an account? <a id="switchToSignup">Sign up</a>
                </div>
                <div class="auth-switch">
                    Or <a id="continueAnonymously">continue anonymously</a>
                </div>
            </div>
            
            <!-- Sign Up Form -->
            <div id="signupForm" class="auth-form">
                <div class="form-group">
                    <label for="signupName">Display Name:</label>
                    <input type="text" id="signupName" class="input-field" placeholder="Enter your name">
                </div>
                <div class="form-group">
                    <label for="signupEmail">Email:</label>
                    <input type="email" id="signupEmail" class="input-field" placeholder="Enter your email">
                </div>
                <div class="form-group">
                    <label for="signupPassword">Password:</label>
                    <input type="password" id="signupPassword" class="input-field" placeholder="Enter your password">
                </div>
                <button id="signupBtn" class="button">Sign Up</button>
                <div class="auth-switch">
                    Already have an account? <a id="switchToSignin">Sign in</a>
                </div>
                <div class="auth-switch">
                    Or <a id="continueAnonymously2">continue anonymously</a>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Contact link -->
    <a href="https://www.facebook.com/NativeEritrean" target="_blank" id="contactUsLink">Contact Us</a>

    <!-- Firebase SDK -->
    <script type="module">
        // Import Firebase modules
        import { initializeApp } from "https://www.gstatic.com/firebasejs/9.6.1/firebase-app.js";
        import { getDatabase, ref, push, set, query, get, orderByChild, limitToLast } from "https://www.gstatic.com/firebasejs/9.6.1/firebase-database.js";
        import { 
            getAuth, 
            signInAnonymously, 
            onAuthStateChanged, 
            createUserWithEmailAndPassword, 
            signInWithEmailAndPassword, 
            signOut,
            updateProfile
        } from "https://www.gstatic.com/firebasejs/9.6.1/firebase-auth.js";

        // Firebase configuration
        const firebaseConfig = {
            apiKey: "AIzaSyDyOgYzDMZdo5V21T8fgHTvPhfgIavuxBA",
            authDomain: "kunama-academy-data.firebaseapp.com",
            databaseURL: "https://kunama-academy-data-default-rtdb.firebaseio.com",
            projectId: "kunama-academy-data",
            storageBucket: "kunama-academy-data.firebasestorage.app",
            messagingSenderId: "1089407925060",
            appId: "1:1089407925060:web:260a1f597ed520fc977511"
        };

        // Initialize Firebase
        const app = initializeApp(firebaseConfig);
        const db = getDatabase(app);
        const auth = getAuth(app);
		
        
        // Authentication state
        let currentUser = null;
        let isAnonymous = true;
        
        // Global quiz variables
        let quizQuestions = [];
        let currentQuestionIndex = 0;
        let score = 0;
        let currentStreak = 0;
        let highScore = 0;
        let selectedDifficulty = "medium"; // Default difficulty
        let timerValue = 15; // Default timer value in seconds
        let timerInterval; // For the timer

        // ==================== NAVIGATION FUNCTIONALITY - NEW ====================
        
		function setupNavigation() {
			// Get all navigation items and content sections
			const navItems = document.querySelectorAll('.nav-item');
			const contentSections = document.querySelectorAll('.content-section');
			
			// Add click event to each nav item
			navItems.forEach(item => {
				item.addEventListener('click', () => {
					// Remove active class from all nav items and content sections
					navItems.forEach(nav => nav.classList.remove('active'));
					contentSections.forEach(section => section.classList.remove('active'));
					
					// Add active class to clicked nav item
					item.classList.add('active');
					
					// Show corresponding content section
					let sectionId = '';
					if (item.id === 'navSearch') sectionId = 'searchSection';
					else if (item.id === 'navAdd') sectionId = 'addSection';
					else if (item.id === 'navQuiz') sectionId = 'quizSection';
					else if (item.id === 'navLeaderboard') sectionId = 'leaderboardSection';
					
					document.getElementById(sectionId).classList.add('active');
				});
			});
		}

				// ==================== QUIZ FUNCTIONALITY - NEW ====================
		// Function to set difficulty
		function setDifficulty(difficulty) {
			selectedDifficulty = difficulty;
			
			// Update UI
			document.querySelectorAll('.difficulty-button').forEach(button => {
				button.classList.remove('selected');
			});
			
			document.querySelector(`.difficulty-button:nth-of-type(${
				difficulty === 'easy' ? 1 : difficulty === 'medium' ? 2 : 3
			})`).classList.add('selected');
			
			// Set timer based on difficulty
			if (difficulty === 'easy') {
				timerValue = 30; // 30 seconds for easy
			} else if (difficulty === 'medium') {
				timerValue = 15; // 15 seconds for medium
			} else {
				timerValue = 10; // 10 seconds for hard
			}
			
			document.getElementById('timer').innerText = timerValue;
		}

		// Function to add quit button to the question container
		function addQuitButton() {
			const questionContainer = document.getElementById("questionContainer");
			
			// Check if quit button already exists to avoid duplicates
			if (!document.getElementById("quitQuizButton")) {
				const quitButtonContainer = document.createElement("div");
				quitButtonContainer.style.marginTop = "20px";
				quitButtonContainer.style.textAlign = "center";
				
				const quitButton = document.createElement("button");
				quitButton.id = "quitQuizButton";
				quitButton.className = "button button-secondary";
				quitButton.style.maxWidth = "200px";
				quitButton.textContent = "Quit Quiz";
				quitButton.onclick = quitQuiz;
				
				quitButtonContainer.appendChild(quitButton);
				questionContainer.appendChild(quitButtonContainer);
			}
		}

		// Function to handle quitting the quiz
		function quitQuiz() {
			// Stop any running timer
			clearInterval(timerInterval);
			
			// Show confirmation dialog
			if (confirm("Are you sure you want to quit this quiz? Your progress will be lost.")) {
				// Reset quiz state
				quizQuestions = [];
				currentQuestionIndex = 0;
				score = 0;
				currentStreak = 0;
				
				// Hide quiz-related containers
				document.getElementById("questionContainer").style.display = "none";
				document.getElementById("quizFinished").style.display = "none";
				document.getElementById("quizLoading").style.display = "none";
				
				// Show the quiz info section
				document.getElementById("quizInfo").style.display = "block";
				
				// Go back to the search tab/home page
				document.getElementById('navSearch').click();
				
				// Show notification
				showNotification("Quiz exited", "success");
			} else {
				// If user cancels, restart the timer
				startTimer();
			}
		}

		// Function to start a new quiz
		async function startQuiz() {
			// Show loading indicator and reset display states
			document.getElementById("quizInfo").style.display = "none";
			document.getElementById("quizLoading").style.display = "block";
			document.getElementById("questionContainer").style.display = "none";
			document.getElementById("quizFinished").style.display = "none";
			
			// Reset quiz state
			quizQuestions = [];
			currentQuestionIndex = 0;
			score = 0;
			currentStreak = 0;
			
			try {
				// Get approved phrases from Firebase - ONLY from approved_phrases
				const approvedPhrasesRef = ref(db, 'approved_phrases');
				console.log("Fetching data from 'approved_phrases'");
				
				const snapshot = await get(approvedPhrasesRef);
				
				// Check if we have any data
				if (!snapshot.exists() || snapshot.size === 0) {
					console.log("No data found in 'approved_phrases'");
					document.getElementById("quizLoading").style.display = "none";
					document.getElementById("quizInfo").style.display = "block";
					document.getElementById("quizInfo").innerHTML = `
						<p>No approved phrases found in the database to create quiz questions.</p>
						<p>Please wait for submissions to be approved before trying the quiz.</p>
						<button class="button" onclick="document.getElementById('navSearch').click()">Return to Search</button>
					`;
					return;
				}
				
				// Process the data
				const allPhrases = [];
				snapshot.forEach(childSnapshot => {
					const phraseData = childSnapshot.val();
					
					// Make sure the entry has both phrase and translation fields
					if (phraseData.phrase && phraseData.translation) {
						allPhrases.push(phraseData);
					}
				});
				
				// We need at least 4 phrases for a quiz with options
				if (allPhrases.length >= 4) {
					// Shuffle array using Fisher-Yates algorithm
					for (let i = allPhrases.length - 1; i > 0; i--) {
						const j = Math.floor(Math.random() * (i + 1));
						[allPhrases[i], allPhrases[j]] = [allPhrases[j], allPhrases[i]];
					}
					
					// Take first 10 phrases or fewer if not enough
					const questionCount = Math.min(10, allPhrases.length);
					
					// Prepare quiz questions
					for (let i = 0; i < questionCount; i++) {
						// Decide randomly if we're testing English to Kunama or Kunama to English
						const isEnglishToKunama = Math.random() > 0.5;
						
						const correctAnswer = allPhrases[i];
						
						// Determine correct answer text based on direction
						const correctAnswerText = isEnglishToKunama ? correctAnswer.translation : correctAnswer.phrase;
						
						// Initialize options array with correct answer
						let options = [correctAnswerText];
						
						// Get 3 random incorrect options
						let attemptCount = 0;
						while (options.length < 4 && attemptCount < 20) {
							attemptCount++;
							const randomIndex = Math.floor(Math.random() * allPhrases.length);
							const randomOption = isEnglishToKunama ? 
								allPhrases[randomIndex].translation : 
								allPhrases[randomIndex].phrase;
							
							// Make sure we don't add duplicates
							if (!options.includes(randomOption) && randomOption !== correctAnswerText) {
								options.push(randomOption);
							}
						}
						
						// If we couldn't get enough options, fill with dummy options
						while (options.length < 4) {
							options.push(`Option ${options.length + 1}`);
						}
						
						// Shuffle options
						for (let j = options.length - 1; j > 0; j--) {
							const k = Math.floor(Math.random() * (j + 1));
							[options[j], options[k]] = [options[k], options[j]];
						}
						
						// Create question object
						const question = {
							prompt: isEnglishToKunama ? correctAnswer.phrase : correctAnswer.translation,
							options: options,
							correctAnswer: correctAnswerText,
							isEnglishToKunama: isEnglishToKunama
						};
						
						quizQuestions.push(question);
					}
					
					// Start showing questions
					showQuestion();
				} else {
					document.getElementById("quizLoading").style.display = "none";
					document.getElementById("quizInfo").style.display = "block";
					document.getElementById("quizInfo").innerHTML = `
						<p>Not enough phrases available for a quiz. At least 4 phrases are needed.</p>
						<p>Currently found: ${allPhrases.length} usable phrase(s).</p>
						<button class="button" onclick="document.getElementById('navSearch').click()">Return to Search</button>
					`;
				}
			} catch (error) {
				console.error("Error fetching phrases for quiz:", error);
				document.getElementById("quizLoading").style.display = "none";
				document.getElementById("quizInfo").style.display = "block";
				document.getElementById("quizInfo").innerHTML = `
					<p>❌ Error loading quiz data: ${error.message}</p>
					<p>Please check the browser console for more details.</p>
					<button class="button" onclick="document.getElementById('navSearch').click()">Return to Search</button>
				`;
			}
		}

		// Function to start the timer
		function startTimer() {
			// Clear any existing timer
			clearInterval(timerInterval);
			
			let timeLeft = timerValue;
			document.getElementById('timer').innerText = timeLeft;
			document.getElementById('timer').classList.remove('timer-warning');
			
			timerInterval = setInterval(() => {
				timeLeft--;
				document.getElementById('timer').innerText = timeLeft;
				
				// Add warning class when time is running out
				if (timeLeft <= 5) {
					document.getElementById('timer').classList.add('timer-warning');
				}
				
				// Time's up
				if (timeLeft <= 0) {
					clearInterval(timerInterval);
					handleTimerExpired();
				}
			}, 1000);
		}

		// Function to handle timer expiry
		function handleTimerExpired() {
			// Disable all options
			const optionButtons = document.querySelectorAll(".quiz-option");
			optionButtons.forEach(button => {
				button.disabled = true;
				
				// Highlight correct answer
				if (button.innerText === quizQuestions[currentQuestionIndex].correctAnswer) {
					button.classList.add("correct-answer");
				}
			});
			
			// Reset streak
			currentStreak = 0;
			document.getElementById('streakCounter').innerText = `Current streak: ${currentStreak}`;
			
			// Show feedback
			const feedback = document.getElementById("questionFeedback");
			feedback.innerText = "⏱️ Time's up! You didn't answer in time.";
			feedback.style.color = "#F44336";
			feedback.style.backgroundColor = "#FFEBEE";
			feedback.style.display = "block";
			
			// Show next button
			document.getElementById("nextButton").style.display = "block";
		}

		// Function to display the current question
		function showQuestion() {
			document.getElementById("quizLoading").style.display = "none";
			
			if (currentQuestionIndex >= quizQuestions.length) {
				// Quiz is finished
				finishQuiz();
				return;
			}
			
			const question = quizQuestions[currentQuestionIndex];
			const questionType = question.isEnglishToKunama ? "English to Kunama" : "Kunama to English";
			
			// Update progress
			document.getElementById("quizProgress").innerText = `Question ${currentQuestionIndex + 1} of ${quizQuestions.length}`;
			
			// Update streak counter
			document.getElementById("streakCounter").innerText = `Current streak: ${currentStreak}`;
			
			// Set question
			document.getElementById("questionType").innerText = questionType;
			document.getElementById("questionPrompt").innerText = question.prompt;
			
			// Clear previous options
			const optionsContainer = document.getElementById("quizOptions");
			optionsContainer.innerHTML = "";
			
			// Add new options
			question.options.forEach((option, index) => {
				optionsContainer.innerHTML += `
					<button class="quiz-option" onclick="window.checkAnswer(${index})">${option}</button>
				`;
			});
			
			// Reset and start the timer
			startTimer();
			
			// Reset feedback and show the question container
			document.getElementById("questionFeedback").style.display = "none";
			document.getElementById("questionContainer").style.display = "block";
			
			// Add the quit button
			addQuitButton();
		}

		// Function to check the selected answer
		function checkAnswer(selectedIndex) {
			// Stop the timer
			clearInterval(timerInterval);
			
			const question = quizQuestions[currentQuestionIndex];
			const selectedOption = question.options[selectedIndex];
			const isCorrect = selectedOption === question.correctAnswer;
			
			// Disable all option buttons
			const optionButtons = document.querySelectorAll(".quiz-option");
			optionButtons.forEach(button => {
				button.disabled = true;
				
				// Highlight the correct answer
				if (button.innerText === question.correctAnswer) {
					button.classList.add("correct-answer");
				}
				
				// If this is the selected wrong answer, highlight it
				if (button.innerText === selectedOption && !isCorrect) {
					button.classList.add("wrong-answer");
				}
			});
			
			// Update score if correct
			if (isCorrect) {
				score++;
				currentStreak++;
				
				// Give bonus points for fast answers in hard mode
				if (selectedDifficulty === 'hard' && parseInt(document.getElementById('timer').innerText) > timerValue/2) {
					score++; // Bonus point for fast answer in hard mode
				}
			} else {
				// Reset streak on wrong answer
				currentStreak = 0;
			}
			
			// Update streak counter
			document.getElementById("streakCounter").innerText = `Current streak: ${currentStreak}`;
			
			// Show feedback
			const feedback = document.getElementById("questionFeedback");
			if (isCorrect) {
				let feedbackText = "✅ Correct!";
				
				// Add streak message if streak is at least 3
				if (currentStreak >= 3) {
					feedbackText += ` 🔥 ${currentStreak} in a row!`;
				}
				
				// Add bonus point message if in hard mode and answered quickly
				if (selectedDifficulty === 'hard' && parseInt(document.getElementById('timer').innerText) > timerValue/2) {
					feedbackText += " +1 bonus point for quick answer!";
				}
				
				feedback.innerText = feedbackText;
				feedback.style.color = "#4CAF50";
				feedback.style.backgroundColor = "#E8F5E9";
			} else {
				feedback.innerText = `❌ Incorrect. The correct answer is: ${question.correctAnswer}`;
				feedback.style.color = "#C62828";
				feedback.style.backgroundColor = "#FFEBEE";
			}
			feedback.style.display = "block";
			
			// Show next button
			document.getElementById("nextButton").style.display = "block";
		}

		// Function to move to the next question
		function nextQuestion() {
			// Reset feedback and next button
			document.getElementById("questionFeedback").style.display = "none";
			document.getElementById("nextButton").style.display = "none";
			
			// Move to next question
			currentQuestionIndex++;
			showQuestion();
		}

		// Function to update high score
		function updateHighScore() {
			const percentage = Math.round((score / quizQuestions.length) * 100);
			
			// Get existing high score from localStorage or default to 0
			const existingHighScore = localStorage.getItem('kunamaQuizHighScore') || 0;
			
			// Update if current score is higher
			if (percentage > existingHighScore) {
				highScore = percentage;
				localStorage.setItem('kunamaQuizHighScore', highScore);
				
				// Show congratulations message if it's a new high score
				if (existingHighScore > 0) {
					document.getElementById('highScoreValue').innerHTML = 
						`${highScore}% <span style="color: #4CAF50; font-size: 14px;">(New Record!)</span>`;
				} else {
					document.getElementById('highScoreValue').innerText = `${highScore}%`;
				}
			} else {
				highScore = existingHighScore;
				document.getElementById('highScoreValue').innerText = `${highScore}%`;
			}
		}

		// Function to finish the quiz
		function finishQuiz() {
			// Stop any running timer
			clearInterval(timerInterval);
			
			// Hide question container and show results
			document.getElementById("questionContainer").style.display = "none";
			document.getElementById("quizFinished").style.display = "block";
			
			// Calculate final score with potential bonus points
			const totalQuestions = quizQuestions.length;
			const possiblePoints = selectedDifficulty === 'hard' ? totalQuestions * 2 : totalQuestions;
			const percentage = Math.round((score / possiblePoints) * 100);
			
			// Display score with appropriate label
			let scoreDisplay = `${score} / ${totalQuestions}`;
			if (selectedDifficulty === 'hard') {
				scoreDisplay += ` (with bonus points: ${score}/${possiblePoints})`;
			}
			scoreDisplay += ` (${percentage}%)`;
			document.getElementById("quizScore").innerText = scoreDisplay;
			
			// Give feedback based on score percentage and difficulty
			let feedbackMessage;
			if (percentage >= 90) {
				if (selectedDifficulty === 'hard') {
					feedbackMessage = "🏆 Incredible! You're a true Kunama language expert! 🎓";
				} else {
					feedbackMessage = "🌟 Excellent! You're a Kunama master! 🎓";
				}
			} else if (percentage >= 70) {
				feedbackMessage = "🎯 Great job! You're getting very good at Kunama! 👍";
			} else if (percentage >= 50) {
				feedbackMessage = "💪 Good effort! Keep practicing to improve.";
			} else {
				feedbackMessage = "📚 Keep learning! Practice makes perfect.";
			}
			
			// Add difficulty-specific message
			switch (selectedDifficulty) {
				case 'easy':
					feedbackMessage += " Try the medium difficulty next time!";
					break;
				case 'medium':
					feedbackMessage += " Challenge yourself with hard mode!";
					break;
				case 'hard':
					feedbackMessage += " Hard mode is a real challenge - great work!";
					break;
			}
			
			document.getElementById("quizFeedback").innerText = feedbackMessage;
			
			// Update high score
			updateHighScore();
			// Add this to the end of your finishQuiz function
			saveQuizResultToLeaderboard();
		}

        // ==================== ORIGINAL FUNCTIONALITY ====================
        
        // Authentication user management
        function setupAuthentication() {
            // Auth state changes
            onAuthStateChanged(auth, (user) => {
                if (user) {
                    // User is signed in
                    currentUser = user;
                    isAnonymous = user.isAnonymous;
                    console.log("User is signed in with ID:", user.uid);
                    
                    // Store the user ID as contributor ID
                    localStorage.setItem("kunama_contributor_id", user.uid);
                    
                    // Update UI for authenticated user
                    updateAuthUI();
                } else {
                    // User is signed out
                    console.log("User is signed out");
                    currentUser = null;
                    isAnonymous = true;
                    
                    // Update UI for signed out user
                    updateAuthUI();
                }
            });
            
            // Add click event to user menu button
            document.getElementById('userMenuBtn').addEventListener('click', () => {
                if (currentUser) {
                    // Show profile section
                    toggleProfileSection();
                } else {
                    // Show auth modal
                    showAuthModal();
                }
            });
            
            // Setup auth modal
            setupAuthModal();
            
            // Setup profile section
            setupProfileSection();
        }
        
        // Update UI based on authentication state
        function updateAuthUI() {
            const userNameElement = document.getElementById('userName');
            const userIconElement = document.getElementById('userIcon');
            
            if (currentUser) {
                // Get display name from different sources in order of preference
                let displayName = getDisplayName();
                
                // Update user menu
                userNameElement.textContent = displayName;
                userIconElement.textContent = '👤';
                
                // Update profile section
                document.getElementById('profileName').textContent = displayName;
                document.getElementById('profileEmail').textContent = currentUser.email || 'Anonymous User';
                document.getElementById('profileAvatar').textContent = getInitials(displayName);
                document.getElementById('displayNameInput').value = displayName;
            } else {
                // Update for non-authenticated user
                userNameElement.textContent = 'Sign in';
                userIconElement.textContent = '👤';
                
                // Hide profile section if it's open
                document.getElementById('userProfileSection').style.display = 'none';
            }
        }
        
        // Toggle profile section visibility
        function toggleProfileSection() {
            const profileSection = document.getElementById('userProfileSection');
            
            if (profileSection.style.display === 'none' || !profileSection.style.display) {
                profileSection.style.display = 'block';
            } else {
                profileSection.style.display = 'none';
            }
        }
        
        // Get display name from various sources
        function getDisplayName() {
            // Order of preference: 
            // 1. Custom display name in localStorage
            // 2. Firebase auth display name
            // 3. Email username
            // 4. "Anonymous User"
            const storedName = localStorage.getItem('kunama_display_name');
            
            if (storedName) {
                return storedName;
            } else if (currentUser && currentUser.displayName) {
                return currentUser.displayName;
            } else if (currentUser && currentUser.email) {
                return currentUser.email.split('@')[0];
            } else {
                return 'Anonymous User';
            }
        }
        
        // Get initials from name for avatar
        function getInitials(name) {
            if (!name || name === 'Anonymous User') return '?';
            
            const parts = name.split(' ');
            if (parts.length === 1) {
                return name.charAt(0).toUpperCase();
            } else {
                return (parts[0].charAt(0) + parts[parts.length - 1].charAt(0)).toUpperCase();
            }
        }
        
        // Setup auth modal
        function setupAuthModal() {
            // Tab switching
            document.querySelectorAll('.auth-tab').forEach(tab => {
                tab.addEventListener('click', () => {
                    // Remove active class from all tabs
                    document.querySelectorAll('.auth-tab').forEach(t => t.classList.remove('active'));
                    document.querySelectorAll('.auth-form').forEach(f => f.classList.remove('active'));
                    
                    // Add active class to clicked tab
                    tab.classList.add('active');
                    document.getElementById(tab.dataset.tab + 'Form').classList.add('active');
                });
            });
            
            // Switch between forms
            document.getElementById('switchToSignup').addEventListener('click', () => {
                document.querySelector('.auth-tab[data-tab="signup"]').click();
            });
            
            document.getElementById('switchToSignin').addEventListener('click', () => {
                document.querySelector('.auth-tab[data-tab="signin"]').click();
            });
            
            // Continue anonymously
            document.getElementById('continueAnonymously').addEventListener('click', () => {
                signInAnonymously(auth)
                    .then(() => {
                        hideAuthModal();
                        showNotification('Continuing anonymously');
                    })
                    .catch(error => {
                        console.error('Error signing in anonymously:', error);
                        showNotification('Failed to sign in anonymously', 'error');
                    });
            });
            
            document.getElementById('continueAnonymously2').addEventListener('click', () => {
                signInAnonymously(auth)
                    .then(() => {
                        hideAuthModal();
                        showNotification('Continuing anonymously');
                    })
                    .catch(error => {
                        console.error('Error signing in anonymously:', error);
                        showNotification('Failed to sign in anonymously', 'error');
                    });
            });
            
            // Sign in
            document.getElementById('signinBtn').addEventListener('click', () => {
                const email = document.getElementById('signinEmail').value;
                const password = document.getElementById('signinPassword').value;
                
                if (!email || !password) {
                    showNotification('Please enter both email and password', 'error');
                    return;
                }
                
                signInWithEmailAndPassword(auth, email, password)
                    .then(() => {
                        hideAuthModal();
                        showNotification('Signed in successfully');
                    })
                    .catch(error => {
                        console.error('Error signing in:', error);
                        showNotification('Failed to sign in: ' + error.message, 'error');
                    });
            });
            
            // Sign up
            document.getElementById('signupBtn').addEventListener('click', () => {
                const name = document.getElementById('signupName').value;
                const email = document.getElementById('signupEmail').value;
                const password = document.getElementById('signupPassword').value;
                
                if (!name || !email || !password) {
                    showNotification('Please fill in all fields', 'error');
                    return;
                }
                
                createUserWithEmailAndPassword(auth, email, password)
                    .then(userCredential => {
                        // Set display name
                        updateProfile(userCredential.user, {
                            displayName: name
                        }).then(() => {
                            // Also save to localStorage
                            localStorage.setItem('kunama_display_name', name);
                            
                            hideAuthModal();
                            showNotification('Account created successfully');
                        });
                    })
                    .catch(error => {
                        console.error('Error signing up:', error);
                        showNotification('Failed to create account: ' + error.message, 'error');
                    });
            });
        }
        
        // Setup profile section
        function setupProfileSection() {
            // Save profile button
            document.getElementById('saveProfileBtn').addEventListener('click', () => {
                const displayName = document.getElementById('displayNameInput').value;
                
                if (!displayName) {
                    showNotification('Please enter a display name', 'error');
                    return;
                }
                
                // Save to localStorage
                localStorage.setItem('kunama_display_name', displayName);
                
                // If user is authenticated (not anonymous), update profile in Firebase
                if (currentUser && !isAnonymous) {
                    updateProfile(currentUser, {
                        displayName: displayName
                    }).then(() => {
                        updateAuthUI();
                        showNotification('Profile saved successfully');
                    }).catch(error => {
                        console.error('Error updating profile:', error);
                        // Still update local UI since we saved to localStorage
                        updateAuthUI();
                        showNotification('Profile saved locally');
                    });
                } else {
                    // Just update the UI for anonymous users
                    updateAuthUI();
                    showNotification('Profile saved locally');
                }
            });
            
            // Sign out button
            document.getElementById('signOutBtn').addEventListener('click', () => {
                signOut(auth).then(() => {
                    showNotification('Signed out successfully');
                    
                    // Create a placeholder anonymous user for app functionality
                    const contributorId = "anonymous_" + Math.random().toString(36).substr(2, 9);
                    localStorage.setItem("kunama_contributor_id", contributorId);
                    updateAuthUI();
                }).catch(error => {
                    console.error('Error signing out:', error);
                    showNotification('Failed to sign out', 'error');
                });
            });
        }
        
        // Show auth modal
        function showAuthModal() {
            document.getElementById('authModal').style.display = 'flex';
        }
        
        // Hide auth modal
        function hideAuthModal() {
            document.getElementById('authModal').style.display = 'none';
            
            // Clear inputs
            document.getElementById('signinEmail').value = '';
            document.getElementById('signinPassword').value = '';
            document.getElementById('signupName').value = '';
            document.getElementById('signupEmail').value = '';
            document.getElementById('signupPassword').value = '';
        }

        // Utility functions
        function escapeHTML(str) {
            if (!str) return '';
            return str
                .toString()
                .replace(/&/g, "&amp;")
                .replace(/</g, "&lt;")
                .replace(/>/g, "&gt;")
                .replace(/"/g, "&quot;")
                .replace(/'/g, "&#039;");
        }

        function formatRelativeTime(timestamp) {
            if (!timestamp) return "Recently";
            
            const now = new Date();
            const date = new Date(timestamp);
            const diffSeconds = Math.floor((now - date) / 1000);
            
            if (diffSeconds < 60) return "Just now";
            if (diffSeconds < 3600) return `${Math.floor(diffSeconds / 60)} minutes ago`;
            if (diffSeconds < 86400) return `${Math.floor(diffSeconds / 3600)} hours ago`;
            if (diffSeconds < 604800) return `${Math.floor(diffSeconds / 86400)} days ago`;
            
            return date.toLocaleDateString();
        }

        function showNotification(message, type = "success") {
            const notification = document.createElement("div");
            notification.className = `notification ${type}`;
            notification.textContent = message;
            
            document.body.appendChild(notification);
            
            // Fade in
            setTimeout(() => {
                notification.style.opacity = "1";
                notification.style.transform = "translateY(0)";
            }, 10);
            
            // Fade out and remove
            setTimeout(() => {
                notification.style.opacity = "0";
                notification.style.transform = "translateY(-20px)";
                setTimeout(() => {
                    document.body.removeChild(notification);
                }, 300);
            }, 2000);
        }

        function copyToClipboard(text) {
            navigator.clipboard.writeText(text).then(() => {
                showNotification("Copied to clipboard!");
            }).catch(err => {
                console.error('Could not copy text: ', err);
                showNotification("Copy failed", "error");
            });
        }

        // Progress bar functionality
        function updateProgressBar() {
            const goal = 5000; // Total goal of submissions
            const submissionCountRef = ref(db, 'submission_count');  // Reference to 'submission_count'

            // Get the current submission count
            get(submissionCountRef).then((snapshot) => {
                const numSubmissions = snapshot.exists() ? snapshot.val() : 0;  // Get the current submission count
                const percentage = Math.min((numSubmissions / goal) * 100, 100);  // Ensure percentage does not exceed 100%

                // Update the progress bar
                document.getElementById("progressBar").style.width = percentage + "%";
                document.getElementById("progressText").innerText = `${numSubmissions} / ${goal} submissions (${Math.round(percentage)}%)`;
            }).catch((error) => {
                console.error("Error fetching submission count:", error);
            });
        }

        // Character counter functionality
        function setupCharacterCounters() {
            const inputFields = [
                { input: document.getElementById("newPhrase"), counter: "phraseCounter", limit: 200 },
                { input: document.getElementById("newTranslation"), counter: "translationCounter", limit: 200 }
            ];
            
            // Create counter elements if they don't exist
            inputFields.forEach(field => {
                const counterEl = document.createElement("span");
                counterEl.id = field.counter;
                counterEl.className = "char-counter";
                field.input.parentNode.insertBefore(counterEl, field.input.nextSibling);
                
                // Initial count
                updateCounter(field.input, counterEl, field.limit);
                
                // Add event listener for input changes
                field.input.addEventListener("input", () => {
                    updateCounter(field.input, counterEl, field.limit);
                });
            });
        }

        // Update counter display
        function updateCounter(inputElement, counterElement, limit) {
            const currentLength = inputElement.value.length;
            counterElement.textContent = `${currentLength}/${limit}`;
            
            // Visual feedback for approaching limit
            if (currentLength > limit * 0.8) {
                counterElement.style.color = "#ff9800";
            } else {
                counterElement.style.color = "#777";
            }
            
            // Visual feedback for exceeding limit
            if (currentLength > limit) {
                counterElement.style.color = "#f44336";
            }
        }

        // Auto-save functionality
        function setupAutoSave() {
            const inputFields = [
                { id: "newPhrase", storageKey: "kunama_autosave_phrase" },
                { id: "newTranslation", storageKey: "kunama_autosave_translation" },
                { id: "newCategory", storageKey: "kunama_autosave_category" }
            ];
            
            // Load saved data on page load
            inputFields.forEach(field => {
                const savedValue = localStorage.getItem(field.storageKey);
                if (savedValue) {
                    document.getElementById(field.id).value = savedValue;
                }
                
                // Set up auto-save on input
                document.getElementById(field.id).addEventListener("input", (e) => {
                    localStorage.setItem(field.storageKey, e.target.value);
                    showAutoSaveIndicator();
                });
            });
        }

        function showAutoSaveIndicator() {
            // Create or update autosave indicator
            let indicator = document.getElementById("autosaveIndicator");
            if (!indicator) {
                indicator = document.createElement("span");
                indicator.id = "autosaveIndicator";
                indicator.className = "autosave-indicator";
                document.getElementById("addSection").appendChild(indicator);
            }
            
            // Show saving message
            indicator.innerHTML = "Auto-saving...";
            indicator.style.opacity = "1";
            
            // Hide message after delay
            setTimeout(() => {
                indicator.innerHTML = "Saved";
                setTimeout(() => {
                    indicator.style.opacity = "0";
                }, 800);
            }, 700);
        }

        // Clear saved data after successful submission
        function clearAutoSavedData() {
            localStorage.removeItem("kunama_autosave_phrase");
            localStorage.removeItem("kunama_autosave_translation");
            localStorage.removeItem("kunama_autosave_category");
        }

        // Confirmation dialog for submission
        function confirmSubmission(phrase, translation, category, onConfirm) {
            // Create modal elements
            const modalOverlay = document.createElement("div");
            modalOverlay.className = "modal-overlay";
            
            const modalContent = document.createElement("div");
            modalContent.className = "modal-content";
            
            // Add content to modal
            modalContent.innerHTML = `
                <h3>Confirm Submission</h3>
                <p>Are you sure you want to submit the following translation?</p>
                <div class="confirm-details">
                    <p><strong>English:</strong> ${escapeHTML(phrase)}</p>
                    <p><strong>Kunama:</strong> ${escapeHTML(translation)}</p>
                    ${category ? `<p><strong>Category:</strong> ${escapeHTML(category)}</p>` : ''}
                </div>
                <div class="confirm-buttons">
                    <button id="confirmCancel" class="button button-secondary">Cancel</button>
                    <button id="confirmSubmit" class="button">Submit</button>
                </div>
            `;
            
            // Add modal to page
            modalOverlay.appendChild(modalContent);
            document.body.appendChild(modalOverlay);
            
            // Handle buttons
            document.getElementById("confirmCancel").addEventListener("click", () => {
                document.body.removeChild(modalOverlay);
            });
            
            document.getElementById("confirmSubmit").addEventListener("click", () => {
                document.body.removeChild(modalOverlay);
                onConfirm();
            });
        }

        // Add new phrase to Firebase with contributor name
        function addNewPhraseToFirebase(phrase, translation, category = "") {
            // Get contributor ID from Firebase Auth or generate a temporary one
            const contributorId = currentUser ? currentUser.uid : "anonymous_" + Math.random().toString(36).substr(2, 9);
            
            // Get contributor name from various sources
            const contributorName = getDisplayName();
            
            // Save contribution information
            const newSubmissionsRef = ref(db, 'pending_submissions');
            const newPhraseRef = push(newSubmissionsRef);
            set(newPhraseRef, { 
                phrase, 
                translation,
                category, 
                timestamp: new Date().toISOString(),
                contributorId: contributorId,
                contributorName: contributorName
            }).then(() => {
                // Increment the submission count
                const submissionCountRef = ref(db, 'submission_count');
                get(submissionCountRef).then((snapshot) => {
                    const currentCount = snapshot.exists() ? snapshot.val() : 0;
                    const newCount = currentCount + 1;

                    // Update the submission count
                    set(submissionCountRef, newCount)
                        .then(() => {
                            console.log("Submission count updated successfully!");
                        })
                        .catch((error) => {
                            console.error("Error updating submission count:", error);
                        });
                }).catch((error) => {
                    console.error("Error fetching submission count:", error);
                });

                document.getElementById("statusMessage").innerText = "✅ Added, waiting for approval!";
                document.getElementById("newPhrase").value = "";  
                document.getElementById("newTranslation").value = "";
                document.getElementById("newCategory").value = "";
                
                // Clear auto-saved data after successful submission
                clearAutoSavedData();

                // Update the progress bar after successful submission
                updateProgressBar();
                
                // Update contributor leaderboard
                fetchContributorLeaderboard();

                // Show success notification
                showNotification("Translation submitted successfully!", "success");
                
                // Navigate to search tab after successful submission
                document.getElementById('navSearch').click();

                setTimeout(() => {
                    document.getElementById("statusMessage").innerText = "";
                }, 3000);  // Clear the status message after 3 seconds
            }).catch((error) => {
                document.getElementById("statusMessage").innerText = "❌ Error: " + error.message;
                showNotification("Error submitting translation", "error");
            });
        }

        // Recent translations display
        function fetchRecentTranslations() {
            const recentContainer = document.getElementById("recentTranslations");
            const approvedPhrasesRef = ref(db, 'approved_phrases');
            
            // Query to get the 5 most recent approved phrases
            const recentQuery = query(approvedPhrasesRef, orderByChild('timestamp'), limitToLast(5));
            
            get(recentQuery).then((snapshot) => {
                recentContainer.innerHTML = "<h3>Recently Added</h3>";
                
                if (snapshot.exists()) {
                    // Convert to array and reverse to get newest first
                    const entries = [];
                    snapshot.forEach(childSnapshot => {
                        entries.push({
                            id: childSnapshot.key,
                            ...childSnapshot.val()
                        });
                    });
                    
                    // Sort by timestamp (newest first) and take the top 3
                    entries.sort((a, b) => {
                        return new Date(b.timestamp || 0) - new Date(a.timestamp || 0);
                    }).slice(0, 3).forEach(entry => {
                        const entryElement = document.createElement("div");
                        entryElement.className = "recent-item";
                        entryElement.innerHTML = `
                            <p><strong>${escapeHTML(entry.phrase)}</strong> → ${escapeHTML(entry.translation)}</p>
                            <span class="recent-date">${formatRelativeTime(entry.timestamp)}</span>
                        `;
                        recentContainer.appendChild(entryElement);
                    });
                } else {
                    recentContainer.innerHTML += "<p>No recent translations available.</p>";
                }
            }).catch((error) => {
                console.error("Error fetching recent translations:", error);
                recentContainer.innerHTML += "<p>❌ Error loading recent translations.</p>";
            });
        }

        // Contributor leaderboard - filtering out system/admin contributions
        function fetchContributorLeaderboard() {
            const leaderboardContainer = document.getElementById("contributorLeaderboard");
            const submissionsRef = ref(db, 'approved_phrases');
            
            get(submissionsRef).then((snapshot) => {
                if (snapshot.exists()) {
                    // Count contributions by contributor ID/name
                    const contributors = {};
                    
                    // System IDs to exclude from leaderboard
                    const systemIds = [
                        'system', 'admin', 'bot', 'initialize', 'initial',
                        'admin_user', 'administrator', 'init_data', 'migration'
                    ];
                    
                    snapshot.forEach(childSnapshot => {
                        const data = childSnapshot.val();
                        
                        // Get contributor name or ID
                        const contributorName = data.contributorName || data.contributor || "Anonymous";
                        const contributorId = data.contributorId || "";
                        
                        // Skip system/admin/initial contributions
                        if (systemIds.some(id => 
                            contributorId.toLowerCase().includes(id) || 
                            contributorName.toLowerCase().includes(id)
                        )) {
                            return; // Skip this iteration
                        }
                        
                        // Skip entries without timestamp (likely initial data)
                        if (!data.timestamp) {
                            return; // Skip this iteration
                        }
                        
                        // Track contributions
                        if (!contributors[contributorName]) {
                            contributors[contributorName] = 0;
                        }
                        
                        contributors[contributorName]++;
                    });
                    
                    // Convert to array and sort
                    const sortedContributors = Object.entries(contributors)
                        .sort((a, b) => b[1] - a[1])
                        .slice(0, 10); // Top 10 contributors
                    
                    // Display leaderboard
                    leaderboardContainer.innerHTML = "<h3>Top Contributors</h3>";
                    
                    if (sortedContributors.length > 0) {
                        const leaderboardList = document.createElement("ol");
                        leaderboardList.className = "leaderboard-list";
                        
                        sortedContributors.forEach(([name, count], index) => {
                            const listItem = document.createElement("li");
                            let medal = "";
                            
                            // Add medals for top 3
                            if (index === 0) medal = "🥇 ";
                            else if (index === 1) medal = "🥈 ";
                            else if (index === 2) medal = "🥉 ";
                            
                            listItem.innerHTML = `
                                <span class="contributor-name">${medal}${escapeHTML(name)}</span>
                                <span class="contribution-count">${count} translation${count !== 1 ? 's' : ''}</span>
                            `;
                            
                            leaderboardList.appendChild(listItem);
                        });
                        
                        leaderboardContainer.appendChild(leaderboardList);
                    } else {
                        leaderboardContainer.innerHTML += "<p>No user contributions yet. Be the first!</p>";
                    }
                } else {
                    leaderboardContainer.innerHTML = "<h3>Top Contributors</h3><p>No contributors yet.</p>";
                }
            }).catch((error) => {
                console.error("Error fetching contributor data:", error);
                leaderboardContainer.innerHTML = "<h3>Top Contributors</h3><p>❌ Error loading contributor data.</p>";
            });
        }

        // Search functionality
        let debounceTimer;

        async function searchPhraseInFirebase(searchTerm) {
            if (!searchTerm) {
                document.getElementById("results").innerHTML = ""; // Clear results if no search term
                return [];
            }

            const approvedPhrasesRef = ref(db, 'approved_phrases');
            const searchTermLower = searchTerm.toLowerCase();

            document.getElementById("results").innerHTML = "<p>Loading...</p>"; // Show loading indicator

            try {
                // Parallel queries for approved phrases
                const [snapshotApproved] = await Promise.all([get(approvedPhrasesRef)]);

                const resultsContainer = document.getElementById("results");
                resultsContainer.innerHTML = "";  // Clear previous results

                let exactMatches = [];
                let partialMatches = [];
                
                // Function to process snapshot data
                const processSnapshot = (snapshot) => {
                    snapshot.forEach((childSnapshot) => {
                        const entry = childSnapshot.val();
                        entry.id = childSnapshot.key; // Store the database key
                        
                        const phraseLower = entry.phrase.toLowerCase();
                        const translationLower = entry.translation.toLowerCase();

                        // Check for exact match first
                        if (phraseLower === searchTermLower || translationLower === searchTermLower) {
                            exactMatches.push(entry); // Add exact match
                        }
                        // Check for partial match if no exact match
                        else if (phraseLower.includes(searchTermLower) || translationLower.includes(searchTermLower)) {
                            partialMatches.push(entry); // Add partial match
                        }
                    });
                };

                // Process both snapshots
                if (snapshotApproved.exists()) {
                    processSnapshot(snapshotApproved);
                }

                // Combine exact and partial matches
                const allResults = [...exactMatches, ...partialMatches];

                // Sort results to prioritize exact matches
                allResults.sort((a, b) => {
                    const aIsExact = a.phrase.toLowerCase() === searchTermLower || a.translation.toLowerCase() === searchTermLower;
                    const bIsExact = b.phrase.toLowerCase() === searchTermLower || b.translation.toLowerCase() === searchTermLower;
                    return bIsExact - aIsExact; // Prioritize exact matches (true > false)
                });

                // Display results
                displayResults(allResults, resultsContainer);
                
                return allResults; // Return results
            } catch (error) {
                console.error("Error searching phrase:", error);
                document.getElementById("results").innerHTML = "<p>❌ Error fetching data.</p>";
                return []; // Return empty array on error
            }
        }

        // Debounce function to limit the number of calls to the search function
        function debounceSearch(event) {
            clearTimeout(debounceTimer);
            debounceTimer = setTimeout(() => {
                searchPhraseInFirebase(event.target.value);
            }, 300);  // Wait 300ms after the user stops typing
        }

        // Display search results
        function displayResults(results, container) {
            if (results.length === 0) {
                container.innerHTML = "<p>No matching phrases found.</p>";
                return;
            }
            
            // Clear container
            container.innerHTML = "";
			// Limit to 3 results only
            const limitedResults = results.slice(0, 3);
            
            // Display results
            limitedResults.forEach(entry => {
                const resultItem = document.createElement("div");
                resultItem.className = "result-item";
                resultItem.setAttribute("data-id", entry.id);
                
                // Format the result item
                resultItem.innerHTML = `
                    <div class="result-content">
                        <p><strong>${escapeHTML(entry.phrase)}</strong> → ${escapeHTML(entry.translation)}</p>
                        ${entry.category ? `<span class="category-tag">${escapeHTML(entry.category)}</span>` : ''}
                    </div>
                    <div class="result-actions">
                        <button class="copy-button" title="Copy to Clipboard">📋</button>
                    </div>
                `;
                
                container.appendChild(resultItem);
                
                // Add event listener for copy button
                resultItem.querySelector(".copy-button").addEventListener("click", () => {
                    copyToClipboard(`${entry.phrase} - ${entry.translation}`);
                });
                
                // Add text-to-speech button if supported
                if ('speechSynthesis' in window) {
                    const actionsContainer = resultItem.querySelector('.result-actions');
                    
                    // Add TTS button for phrase (Kunama)
                    const ttsButtonPhrase = document.createElement('button');
                    ttsButtonPhrase.className = 'tts-button';
                    ttsButtonPhrase.title = 'Speak Kunama';
                    ttsButtonPhrase.setAttribute('data-text', entry.phrase);
                    ttsButtonPhrase.innerHTML = '🔊 KU';
                    actionsContainer.appendChild(ttsButtonPhrase);
                    
                    // Add TTS button for translation (English)
                    const ttsButtonTrans = document.createElement('button');
                    ttsButtonTrans.className = 'tts-button';
                    ttsButtonTrans.title = 'Speak English';
                    ttsButtonTrans.setAttribute('data-text', entry.translation);
                    ttsButtonTrans.innerHTML = '🔊 EN';
                    actionsContainer.appendChild(ttsButtonTrans);
                    
                    // Add event listeners for TTS buttons
                    ttsButtonPhrase.addEventListener('click', () => {
                        speakText(entry.phrase);
                    });
                    
                    ttsButtonTrans.addEventListener('click', () => {
                        speakText(entry.translation);
                    });
                }
                
                // Add vote buttons
                addVoteButtons(resultItem, entry.id);
            });
            
            // Show total results count if more than 3 results exist
            if (results.length > 3) {
                const moreResultsMessage = document.createElement("p");
                moreResultsMessage.style.marginTop = "10px";
                moreResultsMessage.style.fontStyle = "italic";
                moreResultsMessage.textContent = `Showing top 3 of ${results.length} matching results`;
                container.appendChild(moreResultsMessage);
            }
        }

        // Voting system functionality
        function handleVote(phraseId, voteType) {
            // Reference to the votes in the database
            const voteRef = ref(db, `votes/${phraseId}`);
            
            // Get current vote counts
            get(voteRef).then((snapshot) => {
                let upvotes = 0;
                let downvotes = 0;
                
                if (snapshot.exists()) {
                    const data = snapshot.val();
                    upvotes = data.upvotes || 0;
                    downvotes = data.downvotes || 0;
                }
                
                // Update votes based on vote type
                if (voteType === 'up') {
                    upvotes++;
                } else if (voteType === 'down') {
                    downvotes++;
                }
                
                // Save updated votes
                set(voteRef, {
                    upvotes,
                    downvotes,
                    score: upvotes - downvotes,
                    timestamp: new Date().toISOString()
                }).then(() => {
                    // Update UI immediately
                    updateVoteDisplay(phraseId, upvotes, downvotes);
                    
                    // Save voted items to localStorage to prevent duplicate votes
                    saveVoteToLocalStorage(phraseId);
                    
                    // Show notification
                    showNotification("Vote recorded!", "success");
                }).catch((error) => {
                    console.error("Error updating votes:", error);
                    showNotification("Error recording vote", "error");
                });
            }).catch((error) => {
                console.error("Error fetching votes:", error);
                showNotification("Error fetching votes", "error");
            });
        }

        // Add vote buttons to search results
        function addVoteButtons(resultItem, phraseId) {
            // Create vote container
            const voteContainer = document.createElement("div");
            voteContainer.className = "vote-container";
            voteContainer.innerHTML = `
                <span class="vote-label">Helpful?</span>
                <button class="vote-button upvote" data-id="${phraseId}">👍 <span class="vote-count">0</span></button>
                <button class="vote-button downvote" data-id="${phraseId}">👎 <span class="vote-count">0</span></button>
            `;
            
            // Append to result item
            resultItem.appendChild(voteContainer);
            
            // Add event listeners
            voteContainer.querySelector(".upvote").addEventListener("click", (e) => {
                if (!hasVoted(phraseId)) {
                    handleVote(phraseId, 'up');
                } else {
                    showVoteMessage(e.target, "You've already voted");
                }
            });
            
            voteContainer.querySelector(".downvote").addEventListener("click", (e) => {
                if (!hasVoted(phraseId)) {
                    handleVote(phraseId, 'down');
                } else {
                    showVoteMessage(e.target, "You've already voted");
                }
            });
            
            // Load current votes
            loadVotes(phraseId);
        }

        // Load current votes from Firebase
        function loadVotes(phraseId) {
            const voteRef = ref(db, `votes/${phraseId}`);
            get(voteRef).then((snapshot) => {
                if (snapshot.exists()) {
                    const data = snapshot.val();
                    updateVoteDisplay(phraseId, data.upvotes || 0, data.downvotes || 0);
                }
            }).catch((error) => {
                console.error("Error loading votes:", error);
            });
        }

        // Update vote display
        function updateVoteDisplay(phraseId, upvotes, downvotes) {
            const resultItem = document.querySelector(`.result-item[data-id="${phraseId}"]`);
            if (resultItem) {
                resultItem.querySelector(".upvote .vote-count").textContent = upvotes;
                resultItem.querySelector(".downvote .vote-count").textContent = downvotes;
            }
        }

        // Save voted items to localStorage
        function saveVoteToLocalStorage(phraseId) {
            const votedItems = JSON.parse(localStorage.getItem("kunama_voted_items") || "[]");
            if (!votedItems.includes(phraseId)) {
                votedItems.push(phraseId);
                localStorage.setItem("kunama_voted_items", JSON.stringify(votedItems));
            }
        }

        // Check if user has already voted
        function hasVoted(phraseId) {
            const votedItems = JSON.parse(localStorage.getItem("kunama_voted_items") || "[]");
            return votedItems.includes(phraseId);
        }

        // Show vote message
        function showVoteMessage(element, message) {
            const messageEl = document.createElement("span");
            messageEl.className = "vote-message";
            messageEl.textContent = message;
            
            element.parentNode.appendChild(messageEl);
            
            setTimeout(() => {
                messageEl.remove();
            }, 2000);
        }

        // Text-to-speech functionality
        function speakText(text) {
            if ('speechSynthesis' in window) {
                // Cancel any ongoing speech
                window.speechSynthesis.cancel();
                
                // Create a new speech utterance
                const utterance = new SpeechSynthesisUtterance(text);
                
                // Set language based on content
                // Try to detect if it's English or Kunama by checking for common English words
                const commonEnglishWords = ["the", "is", "and", "to", "of", "a", "in", "that", "have", "it"];
                const words = text.toLowerCase().split(/\s+/);
                const containsEnglishWords = words.some(word => commonEnglishWords.includes(word));
                
                // Set language based on detection
                utterance.lang = containsEnglishWords ? 'en-US' : 'und'; // 'und' for undefined/unknown language
                
                // Get available voices
                const voices = window.speechSynthesis.getVoices();
                if (voices.length > 0) {
                    // Try to find an appropriate voice
                    if (containsEnglishWords) {
                        // Find an English voice
                        const englishVoice = voices.find(voice => voice.lang.startsWith('en'));
                        if (englishVoice) utterance.voice = englishVoice;
                    }
                }
                
                // Speak the utterance
                window.speechSynthesis.speak(utterance);
                
                // Show notification
                showNotification("Playing audio...");
            } else {
                showNotification("Text-to-speech is not supported in your browser", "error");
            }
        }

        // Dark mode functionality
        function setupDarkMode() {
            // Create dark mode toggle button
            const darkModeToggle = document.createElement("button");
            darkModeToggle.id = "darkModeToggle";
            darkModeToggle.className = "dark-mode-toggle";
            darkModeToggle.title = "Toggle Dark Mode";
            darkModeToggle.innerHTML = "🌓";
            
            // Add to page
            document.querySelector(".container").appendChild(darkModeToggle);
            
            // Check for saved preference
            const darkModeEnabled = localStorage.getItem("kunama_dark_mode") === "true";
            if (darkModeEnabled) {
                document.body.classList.add("dark-mode");
            }
            
            // Toggle dark mode
            darkModeToggle.addEventListener("click", () => {
                document.body.classList.toggle("dark-mode");
                const isDarkMode = document.body.classList.contains("dark-mode");
                localStorage.setItem("kunama_dark_mode", isDarkMode);
            });
        }

        // Event listeners setup
        function setupEventListeners() {
            // Search input event
            document.getElementById("searchInput").addEventListener("input", debounceSearch);

            // Add phrase button
            document.getElementById("addPhraseButton").addEventListener("click", () => {
                const phrase = document.getElementById("newPhrase").value.trim();
                const translation = document.getElementById("newTranslation").value.trim();
                const category = document.getElementById("newCategory").value;
                
                if (phrase && translation) {
                    confirmSubmission(phrase, translation, category, () => {
                        addNewPhraseToFirebase(phrase, translation, category);
                    });
                } else {
                    showNotification("Please enter both phrase and translation", "error");
                }
            });
            
            // Close auth modal when clicking outside
            document.getElementById("authModal").addEventListener("click", (e) => {
                if (e.target === document.getElementById("authModal")) {
                    hideAuthModal();
                }
            });
            
            // Add keyboard event listener to close modals with Escape key
            document.addEventListener("keydown", (e) => {
                if (e.key === "Escape") {
                    // Hide auth modal
                    if (document.getElementById("authModal").style.display === "flex") {
                        hideAuthModal();
                    }
                    
                    // Hide profile section
                    if (document.getElementById("userProfileSection").style.display === "block") {
                        document.getElementById("userProfileSection").style.display = "none";
                    }
                }
            });
            
            // Submit auth forms on Enter key
            document.getElementById("signinPassword").addEventListener("keydown", (e) => {
                if (e.key === "Enter") {
                    document.getElementById("signinBtn").click();
                }
            });
            
            document.getElementById("signupPassword").addEventListener("keydown", (e) => {
                if (e.key === "Enter") {
                    document.getElementById("signupBtn").click();
                }
            });
        }

        // Initialize application
        window.onload = function() {
            try {
                // Create a placeholder anonymous user ID for app functionality
                if (!localStorage.getItem("kunama_contributor_id")) {
                    const contributorId = "anonymous_" + Math.random().toString(36).substr(2, 9);
                    localStorage.setItem("kunama_contributor_id", contributorId);
                }
                
                // Setup navigation
                setupNavigation();
                
                // Setup quiz functionality
                window.startQuiz = startQuiz;
                window.checkAnswer = checkAnswer;
                window.nextQuestion = nextQuestion;
                window.setDifficulty = setDifficulty;
                
                // Load high score for quiz
                highScore = localStorage.getItem('kunamaQuizHighScore') || 0;
                document.getElementById('highScoreValue').innerText = `${highScore}%`;
                
                // Set default quiz difficulty
                setDifficulty('medium');
                
                // Setup base functionality
                setupEventListeners();
                updateProgressBar();
                setupCharacterCounters();
                setupAutoSave();
                setupDarkMode();
                
                // Fetch data
                fetchRecentTranslations();
                fetchContributorLeaderboard();
                
                // Setup authentication
                setupAuthentication();
                
                // Load available voices for TTS (some browsers need this)
                if ('speechSynthesis' in window) {
                    window.speechSynthesis.onvoiceschanged = function() {
                        // Voices loaded
                        const voices = window.speechSynthesis.getVoices();
                        console.log(`Loaded ${voices.length} voices for speech synthesis`);
                    };
                }
                
                console.log("Application initialization completed successfully.");
            } catch (error) {
                console.error("Error during application initialization:", error);
                showNotification("There was a problem initializing the application. Please refresh the page.", "error");
            }
        };
		
		// ==================== GAMIFICATION & ENHANCED FEATURES ====================

// User progress and gaming variables
let userPoints = 0;
let userStreak = 0;
let userLevel = 1;
let userAchievements = [];
let dailyChallengeCompleted = false;
let lastCompletedDate = null;
let quizVariation = "multiple-choice"; // Default quiz type

// Achievements data
const achievements = [
    {
        id: "first_challenge",
        icon: "🎯",
        title: "First Steps",
        description: "Complete your first daily challenge",
        condition: "Complete 1 daily challenge",
        unlockedAt: null
    },
    {
        id: "three_day_streak",
        icon: "🔥",
        title: "On Fire",
        description: "Maintain a 3-day streak",
        condition: "3-day streak",
        unlockedAt: null
    },
    {
        id: "seven_day_streak",
        icon: "🌟",
        title: "Consistent Learner",
        description: "Maintain a 7-day streak",
        condition: "7-day streak",
        unlockedAt: null
    },
    {
        id: "perfect_quiz",
        icon: "💯",
        title: "Perfect Score",
        description: "Get 100% on a quiz",
        condition: "Perfect quiz score",
        unlockedAt: null
    },
    {
        id: "hard_quiz",
        icon: "😎",
        title: "Challenge Accepted",
        description: "Complete a quiz on hard difficulty",
        condition: "Hard quiz",
        unlockedAt: null
    },
    {
        id: "points_100",
        icon: "⭐",
        title: "Point Collector",
        description: "Earn 100 points",
        condition: "100 points",
        unlockedAt: null
    },
    {
        id: "points_500",
        icon: "🏆",
        title: "Kunama Enthusiast",
        description: "Earn 500 points",
        condition: "500 points",
        unlockedAt: null
    },
    {
        id: "all_quiz_types",
        icon: "🧩",
        title: "Quiz Master",
        description: "Try all quiz types",
        condition: "All quiz types",
        unlockedAt: null
    }
];

// Level data
const levels = [
    { level: 1, title: "Beginner", pointsNeeded: 0, description: "Just starting out" },
    { level: 2, title: "Novice", pointsNeeded: 50, description: "Learning the basics" },
    { level: 3, title: "Apprentice", pointsNeeded: 150, description: "Building vocabulary" },
    { level: 4, title: "Intermediate", pointsNeeded: 300, description: "Growing knowledge" },
    { level: 5, title: "Advanced", pointsNeeded: 500, description: "Getting fluent" },
    { level: 6, title: "Expert", pointsNeeded: 750, description: "Near-native fluency" },
    { level: 7, title: "Master", pointsNeeded: 1000, description: "Mastering Kunama" },
    { level: 8, title: "Scholar", pointsNeeded: 1500, description: "Deep language understanding" }
];

// User progress persistence
function saveUserProgress() {
    const userProgress = {
        points: userPoints,
        streak: userStreak,
        level: userLevel,
        achievements: userAchievements,
        lastCompletedDate: lastCompletedDate,
        dailyChallengeCompleted: dailyChallengeCompleted
    };
    
    localStorage.setItem("kunama_user_progress", JSON.stringify(userProgress));
}

function loadUserProgress() {
    const savedProgress = localStorage.getItem("kunama_user_progress");
    
    if (savedProgress) {
        const progress = JSON.parse(savedProgress);
        userPoints = progress.points || 0;
        userStreak = progress.streak || 0;
        userLevel = progress.level || 1;
        userAchievements = progress.achievements || [];
        lastCompletedDate = progress.lastCompletedDate;
        dailyChallengeCompleted = progress.dailyChallengeCompleted || false;
        
        // Convert lastCompletedDate string to Date object if it exists
        if (lastCompletedDate) {
            lastCompletedDate = new Date(lastCompletedDate);
        }
    }
    
    // Update UI with loaded progress
    updateUserStatsDisplay();
}

// Function to update user stats display
function updateUserStatsDisplay() {
    document.getElementById("statStreak").textContent = userStreak;
    document.getElementById("statPoints").textContent = userPoints;
    document.getElementById("statAchievements").textContent = userAchievements.length;
    
    // Update achievements display
    updateAchievementsDisplay();
    
    // Update level information
    updateLevelInfo();
    
    // Update challenge display
    if (document.getElementById("dailyChallengeSection").classList.contains("active")) {
        updateChallengeDisplay();
    }
}

// Function to add points and update related stats
function addPoints(points, reason = "Activity") {
    userPoints += points;
    
    // Check if level up
    const nextLevel = levels.find(l => l.level > userLevel && userPoints >= l.pointsNeeded);
    
    if (nextLevel) {
        userLevel = nextLevel.level;
        showLevelUpNotification(nextLevel);
    }
    
    // Check for point-based achievements
    checkPointAchievements();
    
    // Save progress
    saveUserProgress();
    
    // Update UI
    updateUserStatsDisplay();
    
    // Show notification
    showNotification(`+ ${points} points: ${reason}`, "success");
    
    // Add to activity feed if it exists
    addActivityEntry(reason, points);
}

// Function to update streak
function updateStreak() {
    const today = new Date();
    today.setHours(0, 0, 0, 0); // Normalize to start of day
    
    if (lastCompletedDate) {
        const lastDate = new Date(lastCompletedDate);
        lastDate.setHours(0, 0, 0, 0);
        
        const diffDays = Math.floor((today - lastDate) / (24 * 60 * 60 * 1000));
        
        if (diffDays === 1) {
            // Consecutive day, increment streak
            userStreak++;
            checkStreakAchievements();
        } else if (diffDays > 1) {
            // Streak broken
            userStreak = 1;
        }
        // If diffDays is 0, it means the user already completed a challenge today
    } else {
        // First time completing a challenge
        userStreak = 1;
        checkStreakAchievements();
    }
    
    lastCompletedDate = today;
    saveUserProgress();
    updateUserStatsDisplay();
}

// Function to check for streak-based achievements
function checkStreakAchievements() {
    if (userStreak === 1 && !hasAchievement("first_challenge")) {
        unlockAchievement("first_challenge");
    }
    
    if (userStreak >= 3 && !hasAchievement("three_day_streak")) {
        unlockAchievement("three_day_streak");
    }
    
    if (userStreak >= 7 && !hasAchievement("seven_day_streak")) {
        unlockAchievement("seven_day_streak");
    }
}

// Function to check for point-based achievements
function checkPointAchievements() {
    if (userPoints >= 100 && !hasAchievement("points_100")) {
        unlockAchievement("points_100");
    }
    
    if (userPoints >= 500 && !hasAchievement("points_500")) {
        unlockAchievement("points_500");
    }
}

// Function to check for quiz-based achievements
function checkQuizAchievements(percentageScore, difficulty) {
    if (percentageScore === 100 && !hasAchievement("perfect_quiz")) {
        unlockAchievement("perfect_quiz");
    }
    
    if (difficulty === "hard" && !hasAchievement("hard_quiz")) {
        unlockAchievement("hard_quiz");
    }
}

// Function to check if user has a specific achievement
function hasAchievement(achievementId) {
    return userAchievements.includes(achievementId);
}

// Function to unlock an achievement
function unlockAchievement(achievementId) {
    if (!hasAchievement(achievementId)) {
        userAchievements.push(achievementId);
        
        // Find achievement details
        const achievement = achievements.find(a => a.id === achievementId);
        
        if (achievement) {
            // Update unlocked timestamp
            achievement.unlockedAt = new Date().toISOString();
            
            // Save progress
            saveUserProgress();
            
            // Show notification
            showAchievementNotification(achievement);
            
            // Update achievements display
            updateAchievementsDisplay();
            
            // Award bonus points for achievement
            addPoints(25, `Achievement: ${achievement.title}`);
        }
    }
}

// Function to show achievement notification
function showAchievementNotification(achievement) {
    const notification = document.createElement("div");
    notification.className = "notification achievement-notification";
    notification.innerHTML = `
        <div class="achievement-icon">${achievement.icon}</div>
        <div class="achievement-text">
            <div class="achievement-title">Achievement Unlocked: ${achievement.title}</div>
            <div>${achievement.description}</div>
        </div>
    `;
    
    // Add special styles for achievement notifications
    notification.style.background = "linear-gradient(135deg, #FF9800, #FF5722)";
    notification.style.display = "flex";
    notification.style.alignItems = "center";
    notification.style.gap = "10px";
    notification.style.padding = "15px";
    
    document.body.appendChild(notification);
    
    // Fade in
    setTimeout(() => {
        notification.style.opacity = "1";
        notification.style.transform = "translateY(0)";
    }, 10);
    
    // Fade out and remove after longer delay (achievements are special!)
    setTimeout(() => {
        notification.style.opacity = "0";
        notification.style.transform = "translateY(-20px)";
        setTimeout(() => {
            document.body.removeChild(notification);
        }, 300);
    }, 5000); // Show for 5 seconds
}

// Function to show level up notification
function showLevelUpNotification(level) {
    const notification = document.createElement("div");
    notification.className = "notification level-up-notification";
    notification.innerHTML = `
        <div class="level-up-icon">🎓</div>
        <div class="level-up-text">
            <div class="level-up-title">Level Up!</div>
            <div>You've reached Level ${level.level}: ${level.title}</div>
        </div>
    `;
    
    // Add special styles for level up notifications
    notification.style.background = "linear-gradient(135deg, #6a11cb, #2575fc)";
    notification.style.display = "flex";
    notification.style.alignItems = "center";
    notification.style.gap = "10px";
    notification.style.padding = "15px";
    
    document.body.appendChild(notification);
    
    // Fade in
    setTimeout(() => {
        notification.style.opacity = "1";
        notification.style.transform = "translateY(0)";
    }, 10);
    
    // Fade out and remove
    setTimeout(() => {
        notification.style.opacity = "0";
        notification.style.transform = "translateY(-20px)";
        setTimeout(() => {
            document.body.removeChild(notification);
        }, 300);
    }, 4000);
}

// Function to update achievements display
function updateAchievementsDisplay() {
    const achievementsGrid = document.getElementById("achievementsGrid");
    
    if (achievementsGrid) {
        achievementsGrid.innerHTML = "";
        
        achievements.forEach(achievement => {
            const isUnlocked = hasAchievement(achievement.id);
            
            const achievementCard = document.createElement("div");
            achievementCard.className = `achievement-card ${isUnlocked ? "unlocked" : "locked"}`;
            
            achievementCard.innerHTML = `
                <div class="achievement-icon">${achievement.icon}</div>
                <div class="achievement-title">${achievement.title}</div>
                <div class="achievement-description">${isUnlocked ? achievement.description : achievement.condition}</div>
            `;
            
            achievementsGrid.appendChild(achievementCard);
        });
    }
}

// Function to update level information
function updateLevelInfo() {
    // Create level indicator if it doesn't exist yet
    let levelIndicator = document.getElementById("levelIndicator");
    
    if (!levelIndicator && document.getElementById("quizSection")) {
        levelIndicator = document.createElement("div");
        levelIndicator.id = "levelIndicator";
        levelIndicator.className = "level-indicator";
        
        // Insert after quiz header
        const quizHeader = document.querySelector("#quizSection h3");
        if (quizHeader) {
            quizHeader.insertAdjacentElement('afterend', levelIndicator);
        }
    }
    
    if (levelIndicator) {
        // Find current level info
        const currentLevel = levels.find(l => l.level === userLevel);
        
        // Find next level info
        const nextLevelIndex = levels.findIndex(l => l.level === userLevel) + 1;
        const nextLevel = nextLevelIndex < levels.length ? levels[nextLevelIndex] : null;
        
        // Calculate progress percentage
        let progressPercentage = 100;
        if (nextLevel) {
            const pointsForCurrentLevel = currentLevel.pointsNeeded;
            const pointsForNextLevel = nextLevel.pointsNeeded;
            const pointsNeeded = pointsForNextLevel - pointsForCurrentLevel;
            const pointsGained = userPoints - pointsForCurrentLevel;
            progressPercentage = Math.min(Math.floor((pointsGained / pointsNeeded) * 100), 100);
        }
        
        // Update level indicator
        levelIndicator.innerHTML = `
            <div class="level-badge">${userLevel}</div>
            <div class="level-info">
                <div class="level-title">${currentLevel.title}</div>
                <div class="level-description">${currentLevel.description}</div>
                <div class="progress-container">
                    <div class="progress-bar" style="width: ${progressPercentage}%"></div>
                </div>
            </div>
        `;
    }
}

// Function to add entry to activity feed
function addActivityEntry(activity, points) {
    // Store in local storage
    const activities = JSON.parse(localStorage.getItem("kunama_activities") || "[]");
    
    activities.unshift({
        activity,
        points,
        date: new Date().toISOString()
    });
    
    // Keep only the most recent 20 activities
    const recentActivities = activities.slice(0, 20);
    
    localStorage.setItem("kunama_activities", JSON.stringify(recentActivities));
}

// Function to get random daily challenge
async function getRandomChallenge() {
    const today = new Date();
    const dateStr = today.toLocaleDateString();
    
    // Check if we have completed today's challenge
    const lastDate = lastCompletedDate ? new Date(lastCompletedDate).toLocaleDateString() : null;
    
    if (lastDate === dateStr) {
        dailyChallengeCompleted = true;
    } else {
        dailyChallengeCompleted = false;
    }
    
    // Set the challenge date
    document.getElementById("challengeDate").innerText = dateStr;
    
    // Set streak counter
    document.getElementById("challengeStreak").innerText = userStreak;
    document.getElementById("userStreak").innerText = userStreak;
    document.getElementById("userPoints").innerText = userPoints;
    
    // If challenge is already completed today, show completion message
    if (dailyChallengeCompleted) {
        document.getElementById("challengeContent").style.display = "none";
        document.getElementById("challengeComplete").style.display = "block";
        return;
    }
    
    // Show challenge content
    document.getElementById("challengeContent").style.display = "block";
    document.getElementById("challengeComplete").style.display = "none";
    
    try {
        // Get approved phrases from Firebase
        const approvedPhrasesRef = ref(db, 'approved_phrases');
        const snapshot = await get(approvedPhrasesRef);
        
        if (!snapshot.exists() || snapshot.size === 0) {
            // No phrases available
            document.getElementById("challengePrompt").innerText = "No phrases available for challenge. Please check back later.";
            return;
        }
        
        // Collect all phrases
        const allPhrases = [];
        snapshot.forEach(childSnapshot => {
            const phraseData = childSnapshot.val();
            if (phraseData.phrase && phraseData.translation) {
                allPhrases.push(phraseData);
            }
        });
        
        if (allPhrases.length === 0) {
            document.getElementById("challengePrompt").innerText = "No valid phrases available for challenge. Please check back later.";
            return;
        }
        
        // Select random challenge type (multiple choice or typing)
        const challengeTypes = ["multiple-choice", "typing"];
        const randomType = challengeTypes[Math.floor(Math.random() * challengeTypes.length)];
        
        // Select random direction (English to Kunama or Kunama to English)
        const isEnglishToKunama = Math.random() > 0.5;
        
        // Select random phrase for challenge
        const randomIndex = Math.floor(Math.random() * allPhrases.length);
        const challengePhrase = allPhrases[randomIndex];
        
        // Get prompts and answers based on direction
        const prompt = isEnglishToKunama ? challengePhrase.phrase : challengePhrase.translation;
        const correctAnswer = isEnglishToKunama ? challengePhrase.translation : challengePhrase.phrase;
        
        // Set challenge type and prompt
        document.getElementById("challengeType").innerText = isEnglishToKunama ? "English to Kunama" : "Kunama to English";
        document.getElementById("challengePrompt").innerText = `How would you say "${prompt}"?`;
        
        // Setup challenge based on type
        if (randomType === "multiple-choice") {
            document.getElementById("challengeOptions").style.display = "flex";
            document.getElementById("challengeInput").style.display = "none";
            
            // Generate options (1 correct + 3 incorrect)
            let options = [correctAnswer];
            
            // Select 3 random incorrect options
            while (options.length < 4 && allPhrases.length >= 4) {
                const randomOptionIndex = Math.floor(Math.random() * allPhrases.length);
                const randomOption = isEnglishToKunama ? allPhrases[randomOptionIndex].translation : allPhrases[randomOptionIndex].phrase;
                
                if (!options.includes(randomOption) && randomOption !== correctAnswer) {
                    options.push(randomOption);
                }
            }
            
            // Shuffle options
            options = shuffleArray(options);
            
            // Add options to the UI
            const optionsContainer = document.getElementById("challengeOptions");
            optionsContainer.innerHTML = "";
            
            options.forEach((option, index) => {
                const optionButton = document.createElement("div");
                optionButton.className = "challenge-option";
                optionButton.textContent = option;
                optionButton.dataset.index = index;
                optionButton.dataset.value = option;
                
                // Add click event
                optionButton.addEventListener("click", function() {
                    // Remove selected class from all options
                    document.querySelectorAll(".challenge-option").forEach(opt => {
                        opt.classList.remove("selected");
                    });
                    
                    // Add selected class to clicked option
                    this.classList.add("selected");
                });
                
                optionsContainer.appendChild(optionButton);
            });
        } else {
            // Typing challenge
            document.getElementById("challengeOptions").style.display = "none";
            document.getElementById("challengeInput").style.display = "block";
            
            // Clear previous input
            document.getElementById("userAnswer").value = "";
        }
        
        // Setup check answer button
        const checkAnswerBtn = document.getElementById("checkAnswerBtn");
        
        // Remove previous event listeners
        const newCheckBtn = checkAnswerBtn.cloneNode(true);
        checkAnswerBtn.parentNode.replaceChild(newCheckBtn, checkAnswerBtn);
        
        // Add new event listener
        newCheckBtn.addEventListener("click", function() {
            let userAnswer = "";
            
            if (randomType === "multiple-choice") {
                const selectedOption = document.querySelector(".challenge-option.selected");
                
                if (!selectedOption) {
                    showNotification("Please select an option", "error");
                    return;
                }
                
                userAnswer = selectedOption.dataset.value;
                
                // Highlight correct/incorrect
                document.querySelectorAll(".challenge-option").forEach(option => {
                    if (option.dataset.value === correctAnswer) {
                        option.classList.add("correct");
                    } else if (option === selectedOption && option.dataset.value !== correctAnswer) {
                        option.classList.add("incorrect");
                    }
                });
            } else {
                // Typing challenge
                userAnswer = document.getElementById("userAnswer").value.trim();
                
                if (!userAnswer) {
                    showNotification("Please enter your answer", "error");
                    return;
                }
            }
            
            // Check if answer is correct
            const isCorrect = userAnswer.toLowerCase() === correctAnswer.toLowerCase();
            
            // Show feedback
            const feedbackEl = document.getElementById("challengeFeedback");
            feedbackEl.style.display = "block";
            
            if (isCorrect) {
                feedbackEl.innerHTML = "✅ Correct! Well done!";
                feedbackEl.className = "challenge-feedback correct";
                
                // Mark challenge as completed
                dailyChallengeCompleted = true;
                
                // Update streak
                updateStreak();
                
                // Award points
                const earnedPoints = 10 + (userStreak > 1 ? 2 * Math.min(userStreak, 5) : 0); // Base + streak bonus
                
                // Show completion message
                document.getElementById("pointsEarned").innerText = earnedPoints;
                
                // Delay showing completion UI to allow seeing feedback
                setTimeout(() => {
                    document.getElementById("challengeContent").style.display = "none";
                    document.getElementById("challengeComplete").style.display = "block";
                    
                    // Add points with slight delay for better UX
                    setTimeout(() => {
                        addPoints(earnedPoints, "Daily Challenge Completed");
                    }, 500);
                }, 1500);
            } else {
                feedbackEl.innerHTML = `❌ Incorrect. The correct answer is: <strong>${correctAnswer}</strong>`;
                feedbackEl.className = "challenge-feedback incorrect";
                
                // Disable check button
                this.disabled = true;
                
                // Allow trying again after 3 seconds
                setTimeout(() => {
                    this.disabled = false;
                    feedbackEl.style.display = "none";
                    
                    if (randomType === "multiple-choice") {
                        // Reset option classes
                        document.querySelectorAll(".challenge-option").forEach(option => {
                            option.classList.remove("selected", "correct", "incorrect");
                        });
                    } else {
                        // Clear input for typing challenge
                        document.getElementById("userAnswer").value = "";
                    }
                }, 3000);
            }
        });
    } catch (error) {
        console.error("Error getting daily challenge:", error);
        document.getElementById("challengePrompt").innerText = "Error loading challenge. Please try again later.";
    }
}

// Function to update challenge display
function updateChallengeDisplay() {
    getRandomChallenge();
}

// Helper to shuffle array
function shuffleArray(array) {
    const newArray = [...array];
    for (let i = newArray.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [newArray[i], newArray[j]] = [newArray[j], newArray[i]];
    }
    return newArray;
}

// Enhanced Quiz Variations
function setupQuizVariations() {
    // Create quiz variation selector if it doesn't exist
    let variationSelector = document.getElementById("quizVariationSelector");
    
    if (!variationSelector && document.getElementById("quizInfo")) {
        variationSelector = document.createElement("div");
        variationSelector.id = "quizVariationSelector";
        variationSelector.className = "quiz-variation-selector";
        
        variationSelector.innerHTML = `
            <h4>Quiz Types:</h4>
            <div class="quiz-type-button active" data-type="multiple-choice">Multiple Choice</div>
            <div class="quiz-type-button" data-type="sentence-completion">Sentence Completion</div>
        `;
        
        // Insert after difficulty selection
        const difficultySelection = document.getElementById("difficultySelection");
        difficultySelection.insertAdjacentElement('afterend', variationSelector);
        
        // Add click events to quiz type buttons
        variationSelector.querySelectorAll(".quiz-type-button").forEach(button => {
            button.addEventListener("click", function() {
                // Remove active class from all buttons
                variationSelector.querySelectorAll(".quiz-type-button").forEach(btn => {
                    btn.classList.remove("active");
                });
                
                // Add active class to clicked button
                this.classList.add("active");
                
                // Update quiz variation
                quizVariation = this.dataset.type;
                
                // Check for "all quiz types" achievement
                checkAllQuizTypesAchievement();
            });
        });
    }
}

// Function to check if all quiz types have been tried
function checkAllQuizTypesAchievement() {
    // Get tried quiz types from localStorage
    const triedTypes = JSON.parse(localStorage.getItem("kunama_tried_quiz_types") || "[]");
    
    // Add current type if not already tried
    if (!triedTypes.includes(quizVariation)) {
        triedTypes.push(quizVariation);
        localStorage.setItem("kunama_tried_quiz_types", JSON.stringify(triedTypes));
        
        // Check if all types have been tried
        const allTypes = ["multiple-choice", "sentence-completion"];
        const hasTriedAll = allTypes.every(type => triedTypes.includes(type));
        
        if (hasTriedAll && !hasAchievement("all_quiz_types")) {
            unlockAchievement("all_quiz_types");
        }
    }
}

// Function to modify quiz start based on selected variation
function startQuizWithVariation() {
    // Modify the existing startQuiz function to support different quiz types
    const originalStartQuiz = window.startQuiz;
    
    window.startQuiz = async function() {
        // Reset UI - common for all quiz types
        document.getElementById("quizInfo").style.display = "none";
        document.getElementById("quizLoading").style.display = "block";
        document.getElementById("questionContainer").style.display = "none";
        document.getElementById("quizFinished").style.display = "none";
        
        // Reset quiz state
        quizQuestions = [];
        currentQuestionIndex = 0;
        score = 0;
        currentStreak = 0;
        
        // Call appropriate quiz type handler based on variation
        switch (quizVariation) {
            case "multiple-choice":
                // Use original quiz implementation
                return originalStartQuiz();
            
            case "sentence-completion":
                return startSentenceCompletionQuiz();
                
            default:
                // Default to original quiz
                return originalStartQuiz();
        }
    };
}

// Sentence Completion Quiz
async function startSentenceCompletionQuiz() {
    try {
        // Get phrases from Firebase
        const approvedPhrasesRef = ref(db, 'approved_phrases');
        const snapshot = await get(approvedPhrasesRef);
        
        if (!snapshot.exists() || snapshot.size === 0) {
            document.getElementById("quizLoading").style.display = "none";
            document.getElementById("quizInfo").style.display = "block";
            document.getElementById("quizInfo").innerHTML = `
                <p>No approved phrases found in the database for sentence completion quiz.</p>
                <button class="button" onclick="document.getElementById('navSearch').click()">Return to Search</button>
            `;
            return;
        }
        
        // Process data
        const allPhrases = [];
        snapshot.forEach(childSnapshot => {
            const phraseData = childSnapshot.val();
            if (phraseData.phrase && phraseData.translation && 
                phraseData.phrase.split(' ').length > 3) { // Only use phrases with at least 4 words
                allPhrases.push(phraseData);
            }
        });
        
        if (allPhrases.length < 3) {
            document.getElementById("quizLoading").style.display = "none";
            document.getElementById("quizInfo").style.display = "block";
            document.getElementById("quizInfo").innerHTML = `
                <p>Not enough suitable phrases for a sentence completion quiz. Need phrases with at least 4 words.</p>
                <button class="button" onclick="document.getElementById('navSearch').click()">Return to Search</button>
            `;
            return;
        }
        
        // Shuffle phrases and prepare quiz questions
        const shuffledPhrases = shuffleArray(allPhrases);
        const questionCount = Math.min(10, shuffledPhrases.length);
        
        for (let i = 0; i < questionCount; i++) {
            const phraseData = shuffledPhrases[i];
            const isEnglishToKunama = Math.random() > 0.5;
            
            // Get phrase to use for sentence completion
            const sentence = isEnglishToKunama ? phraseData.phrase : phraseData.translation;
            const translation = isEnglishToKunama ? phraseData.translation : phraseData.phrase;
            
            // Split sentence into words
            const words = sentence.split(' ');
            
            // Select a random word to remove (not the first or last word)
            const minIndex = 1;
            const maxIndex = Math.max(1, words.length - 2);
            const blankIndex = minIndex + Math.floor(Math.random() * (maxIndex - minIndex + 1));
            
            const removedWord = words[blankIndex];
            
            // Replace with blank
            words[blankIndex] = "____";
            
            // Rejoin sentence
            const sentenceWithBlank = words.join(' ');
            
            // Create options (1 correct + 3 incorrect)
            let options = [removedWord];
            
            // Get incorrect options
            while (options.length < 4) {
                const randomPhraseIndex = Math.floor(Math.random() * allPhrases.length);
                const randomPhrase = allPhrases[randomPhraseIndex];
                const randomSentence = isEnglishToKunama ? randomPhrase.phrase : randomPhrase.translation;
                const randomWords = randomSentence.split(' ');
                
                if (randomWords.length > 1) {
                    const randomWord = randomWords[Math.floor(Math.random() * randomWords.length)];
                    
                    // Only use words that are not too short and not duplicates
                    if (randomWord.length > 2 && !options.includes(randomWord) && randomWord !== removedWord) {
                        options.push(randomWord);
                    }
                }
            }
            
            // Shuffle options
            options = shuffleArray(options);
            
            // Create question object
            const question = {
                prompt: sentenceWithBlank,
                options: options,
                correctAnswer: removedWord,
                translation: translation,
                isEnglishToKunama: isEnglishToKunama,
                type: "sentence-completion"
            };
            
            quizQuestions.push(question);
        }
        
        // Show question
        showSentenceCompletionQuestion();
    } catch (error) {
        console.error("Error starting sentence completion quiz:", error);
        document.getElementById("quizLoading").style.display = "none";
        document.getElementById("quizInfo").style.display = "block";
        document.getElementById("quizInfo").innerHTML = `
            <p>❌ Error loading sentence completion quiz: ${error.message}</p>
            <button class="button" onclick="document.getElementById('navSearch').click()">Return to Search</button>
        `;
    }
}

// Function to show sentence completion question
function showSentenceCompletionQuestion() {
    document.getElementById("quizLoading").style.display = "none";
    
    if (currentQuestionIndex >= quizQuestions.length) {
        // Quiz is finished
        finishQuiz();
        return;
    }
    
    const question = quizQuestions[currentQuestionIndex];
    const questionType = question.isEnglishToKunama ? "English" : "Kunama";
    
    // Update progress
    document.getElementById("quizProgress").innerText = `Question ${currentQuestionIndex + 1} of ${quizQuestions.length}`;
    
    // Update streak counter
    document.getElementById("streakCounter").innerText = `Current streak: ${currentStreak}`;
    
    // Set question type
    document.getElementById("questionType").innerText = `Fill in the blank (${questionType})`;
    
    // Update question prompt - check if we need to modify the UI
    const promptContainer = document.getElementById("questionPrompt");
    
    // For sentence completion, we need to modify the prompt display
    promptContainer.innerHTML = `
        <div class="sentence-completion">
            ${question.prompt}
        </div>
        <p class="hint">Select the correct word to complete the sentence</p>
    `;
    
    // Clear previous options
    const optionsContainer = document.getElementById("quizOptions");
    optionsContainer.innerHTML = "";
    
    // Add options
    question.options.forEach((option, index) => {
        optionsContainer.innerHTML += `
            <button class="quiz-option" onclick="window.checkAnswer(${index})">${option}</button>
        `;
    });
    
    // Reset and start the timer
    startTimer();
    
    // Reset feedback and show the question container
    document.getElementById("questionFeedback").style.display = "none";
    document.getElementById("questionContainer").style.display = "block";
}

// Function to initialize enhanced features
function initEnhancedFeatures() {
    console.log("Initializing enhanced features...");
    
    // Load user progress
    loadUserProgress();
    
    // Setup quiz variations
    setupQuizVariations();
    
    // Enhance quiz start function
    startQuizWithVariation();
    
    // Enhance finish quiz function
    enhancedFinishQuiz = window.finishQuiz;
    
    // Setup Word of the Day
    setupWordOfDay();
    
    console.log("Enhanced features initialized!");
}

// Function to setup word of the day
function setupWordOfDay() {
    // Implementation can be added here if needed
    console.log("Word of the day feature would be initialized here");
}

// Enhanced finish quiz function
function enhancedFinishQuiz() {
    // This function will be implemented by the original code
    console.log("Enhanced quiz finish would be handled here");
}

// MULTIPLAYER FUNCTIONALITY

// Global variables for multiplayer
let activeCompetition = null;
let competitionRoomId = null;
let competitorData = null;
let playerRole = null; // 'host' or 'guest'
let competitionQuestions = [];
let competitionTimer = null;
let waitingForOpponent = false;

// First, let's add a new navigation tab for multiplayer
function addMultiplayerTab() {
    const navContainer = document.querySelector('.nav-container');
    
    if (navContainer && !document.getElementById('navMultiplayer')) {
        const multiplayerTab = document.createElement('div');
        multiplayerTab.id = 'navMultiplayer';
        multiplayerTab.className = 'nav-item new-feature';
        multiplayerTab.textContent = 'Compete';
        
        // Insert before leaderboard tab
        const leaderboardTab = document.getElementById('navLeaderboard');
        navContainer.insertBefore(multiplayerTab, leaderboardTab);
        
        // Add click event
        multiplayerTab.addEventListener('click', () => {
            // Remove active class from all tabs and sections
            document.querySelectorAll('.nav-item').forEach(tab => tab.classList.remove('active'));
            document.querySelectorAll('.content-section').forEach(section => section.classList.remove('active'));
            
            // Add active class to this tab
            multiplayerTab.classList.add('active');
            
            // Show multiplayer section
            showMultiplayerSection();
        });
    }
}

// Create the multiplayer section
function createMultiplayerSection() {
    // First check if it already exists
    if (document.getElementById('multiplayerSection')) {
        return;
    }
    
    const multiplayerSection = document.createElement('div');
    multiplayerSection.id = 'multiplayerSection';
    multiplayerSection.className = 'content-section';
    
    multiplayerSection.innerHTML = `
        <h3>Compete with Friends</h3>
        <div id="multiplayerInfo">
            <p>Challenge a friend to a quiz competition! See who knows Kunama better!</p>
            <div id="connectionStatus"></div>
            
            <div id="multiplayerOptions">
                <div id="createGameContainer">
                    <h4>Create a New Game</h4>
                    <p>Create a game and share the code with a friend</p>
                    <div class="form-group">
                        <label for="gameNameInput">Your Display Name:</label>
                        <input type="text" id="gameNameInput" class="input-field" placeholder="Enter your name" value="${getDisplayName()}">
                    </div>
                    <div class="form-group">
                        <label>Difficulty Level:</label>
                        <div id="mpDifficultySelection" class="quiz-variation-selector">
                            <div class="quiz-type-button" data-type="easy">Easy</div>
                            <div class="quiz-type-button active" data-type="medium">Medium</div>
                            <div class="quiz-type-button" data-type="hard">Hard</div>
                        </div>
                    </div>
                    <button id="createGameBtn" class="button">Create Game</button>
                </div>
                
                <div id="joinGameContainer">
                    <h4>Join a Game</h4>
                    <p>Enter the game code shared by your friend</p>
                    <div class="form-group">
                        <label for="joinNameInput">Your Display Name:</label>
                        <input type="text" id="joinNameInput" class="input-field" placeholder="Enter your name" value="${getDisplayName()}">
                    </div>
                    <div class="form-group">
                        <label for="gameCodeInput">Game Code:</label>
                        <input type="text" id="gameCodeInput" class="input-field" placeholder="Enter 6-digit code">
                    </div>
                    <button id="joinGameBtn" class="button">Join Game</button>
                </div>
            </div>
            
            <div id="activeGamesContainer" style="display: none; margin-top: 20px;">
                <h4>Your Active Games</h4>
                <div id="activeGamesList"></div>
            </div>
        </div>
        
        <div id="waitingRoomContainer" style="display: none; text-align: center;">
            <h4>Waiting for Opponent</h4>
            <div id="gameCodeDisplay" style="font-size: 24px; font-weight: bold; margin: 20px 0; padding: 10px; background: rgba(42, 82, 152, 0.1); border-radius: 10px;"></div>
            <p>Share this code with a friend to join your game</p>
            <button id="copyGameCodeBtn" class="button">Copy Game Code</button>
            <div style="margin-top: 30px;">
                <div class="waiting-animation" style="margin: 0 auto; width: 50px; height: 50px; border: 5px solid #f3f3f3; border-top: 5px solid #3498db; border-radius: 50%; animation: spin 1s linear infinite;"></div>
                <p id="waitingMessage">Waiting for opponent to join...</p>
            </div>
            <button id="cancelWaitingBtn" class="button button-secondary" style="margin-top: 20px;">Cancel</button>
            
            <style>
                @keyframes spin {
                    0% { transform: rotate(0deg); }
                    100% { transform: rotate(360deg); }
                }
            </style>
        </div>
        
        <div id="competitionContainer" style="display: none;">
            <div id="competitionHeader" style="display: flex; justify-content: space-between; margin-bottom: 20px;">
                <div id="player1Info" class="player-info" style="flex: 1; padding: 10px; background: rgba(42, 82, 152, 0.1); border-radius: 8px; text-align: center;">
                    <div class="player-name" style="font-weight: bold;">Player 1</div>
                    <div class="player-score">0 points</div>
                </div>
                <div style="flex: 0.2; display: flex; justify-content: center; align-items: center; font-weight: bold;">VS</div>
                <div id="player2Info" class="player-info" style="flex: 1; padding: 10px; background: rgba(42, 82, 152, 0.1); border-radius: 8px; text-align: center;">
                    <div class="player-name" style="font-weight: bold;">Player 2</div>
                    <div class="player-score">0 points</div>
                </div>
            </div>
            
            <div id="competitionTimer" style="text-align: center; font-size: 20px; font-weight: bold; margin-bottom: 15px;">Time: <span id="mpTimerValue">60</span>s</div>
            
            <div id="competitionQuestion" style="margin: 20px 0;">
                <div id="questionNumber" style="text-align: center; margin-bottom: 10px; color: #666;">Question 1 of 10</div>
                <div id="mpQuestionType" style="text-align: center; font-weight: bold; margin-bottom: 5px;">English to Kunama</div>
                <div id="mpQuestionPrompt" style="text-align: center; font-size: 20px; font-weight: bold; margin-bottom: 20px;">Translation for: Hello</div>
                
                <div id="mpQuizOptions" style="display: flex; flex-direction: column; gap: 10px;">
                    <!-- Options will be inserted here -->
                </div>
                
                <div id="mpQuestionFeedback" style="display: none; margin: 15px 0; padding: 10px; border-radius: 8px; text-align: center; font-weight: bold;"></div>
            </div>
            
            <div id="competitionResults" style="display: none; text-align: center;">
                <h4>Competition Complete!</h4>
                <div id="winnerDisplay" style="font-size: 24px; font-weight: bold; margin: 20px 0;"></div>
                <div id="finalScores" style="margin-bottom: 20px;"></div>
                <button id="newCompetitionBtn" class="button">New Competition</button>
                <button id="returnToMenuBtn" class="button button-secondary">Return to Menu</button>
            </div>
        </div>
    `;
    
    // Add to the container
    document.querySelector('.container').appendChild(multiplayerSection);
    
    // Add event listeners
    setupMultiplayerEvents();
}

// Add the necessary styles for multiplayer
function addMultiplayerStyles() {
    const styleElement = document.createElement('style');
    styleElement.textContent = `
        /* Multiplayer Styles */
        #multiplayerOptions {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            margin: 20px 0;
        }
        
        #createGameContainer, #joinGameContainer {
            flex: 1;
            min-width: 250px;
            padding: 20px;
            background: #f8f8f8;
            border-radius: 10px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            transition: all 0.3s ease;
        }
        
        #createGameContainer:hover, #joinGameContainer:hover {
            transform: translateY(-5px);
            box-shadow: 0 5px 15px rgba(0,0,0,0.15);
        }
        
        body.dark-mode #createGameContainer, 
        body.dark-mode #joinGameContainer {
            background: #333;
        }
        
        .mp-option {
            padding: 12px;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            background: #f9f9f9;
            cursor: pointer;
            transition: all 0.2s ease;
            text-align: left;
        }
        
        .mp-option:hover {
            border-color: #2575fc;
            background: #f0f7ff;
            transform: translateY(-2px);
        }
        
        .mp-option.correct {
            border-color: #4CAF50;
            background: #E8F5E9;
        }
        
        .mp-option.incorrect {
            border-color: #F44336;
            background: #FFEBEE;
        }
        
        .mp-option.opponent-selected::after {
            content: '👉';
            position: absolute;
            right: 10px;
            top: 50%;
            transform: translateY(-50%);
        }
        
        .active-game-item {
            padding: 15px;
            margin: 10px 0;
            background: #f8f8f8;
            border-radius: 8px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .active-game-item:hover {
            background: #f0f0f0;
        }
        
        .active-game-opponent {
            font-weight: bold;
        }
        
        .active-game-status {
            color: #666;
        }
        
        .active-game-actions {
            display: flex;
            gap: 10px;
        }
        
        body.dark-mode #mpQuizOptions .mp-option {
            background: #333;
            color: #e0e0e0;
            border-color: #444;
        }
        
        body.dark-mode #mpQuizOptions .mp-option:hover {
            background: #444;
            border-color: #555;
        }
        
        body.dark-mode .active-game-item {
            background: #333;
        }
        
        body.dark-mode .active-game-item:hover {
            background: #3a3a3a;
        }
        
        body.dark-mode .active-game-status {
            color: #aaa;
        }
        
        /* Game code highlight */
        .game-code {
            letter-spacing: 2px;
            font-family: monospace;
            background: rgba(42, 82, 152, 0.1);
            padding: 2px 5px;
            border-radius: 4px;
        }
        
        body.dark-mode .game-code {
            background: rgba(129, 164, 255, 0.1);
        }
        
        /* Player indicator for current turn */
        .player-info.current-turn {
            box-shadow: 0 0 10px rgba(42, 82, 152, 0.5);
            animation: pulseBorder 1.5s infinite;
        }
        
        @keyframes pulseBorder {
            0% { box-shadow: 0 0 5px rgba(42, 82, 152, 0.5); }
            50% { box-shadow: 0 0 15px rgba(42, 82, 152, 0.8); }
            100% { box-shadow: 0 0 5px rgba(42, 82, 152, 0.5); }
        }
        
        body.dark-mode .player-info.current-turn {
            box-shadow: 0 0 10px rgba(129, 164, 255, 0.5);
        }
        
        body.dark-mode @keyframes pulseBorder {
            0% { box-shadow: 0 0 5px rgba(129, 164, 255, 0.5); }
            50% { box-shadow: 0 0 15px rgba(129, 164, 255, 0.8); }
            100% { box-shadow: 0 0 5px rgba(129, 164, 255, 0.5); }
        }
        
        /* Live player status indicators */
        .player-status {
            display: inline-block;
            width: 10px;
            height: 10px;
            border-radius: 50%;
            margin-right: 5px;
        }
        
        .player-status.online {
            background-color: #4CAF50;
        }
        
        .player-status.offline {
            background-color: #F44336;
        }
        
        /* Mobile responsiveness */
        @media (max-width: 600px) {
            #multiplayerOptions {
                flex-direction: column;
            }
            
            #competitionHeader {
                flex-direction: column;
                gap: 10px;
            }
            
            #competitionHeader > div:nth-child(2) {
                order: -1;
                margin: 5px 0;
            }
        }
    `;
    
    document.head.appendChild(styleElement);
}

// Setup event listeners for multiplayer section
function setupMultiplayerEvents() {
    // Setup difficulty selection
    const difficultyButtons = document.querySelectorAll('#mpDifficultySelection .quiz-type-button');
    difficultyButtons.forEach(button => {
        button.addEventListener('click', () => {
            difficultyButtons.forEach(btn => btn.classList.remove('active'));
            button.classList.add('active');
        });
    });
    
    // Create game button
    document.getElementById('createGameBtn').addEventListener('click', createNewGame);
    
    // Join game button
    document.getElementById('joinGameBtn').addEventListener('click', joinGame);
    
    // Copy game code button
    document.getElementById('copyGameCodeBtn').addEventListener('click', () => {
        const gameCode = document.getElementById('gameCodeDisplay').textContent;
        copyToClipboard(gameCode);
    });
    
    // Cancel waiting button
    document.getElementById('cancelWaitingBtn').addEventListener('click', cancelWaiting);
    
    // New competition button
    document.getElementById('newCompetitionBtn').addEventListener('click', () => {
        // Reset competition view and show multiplayer options
        document.getElementById('competitionContainer').style.display = 'none';
        document.getElementById('multiplayerInfo').style.display = 'block';
    });
    
    // Return to menu button
    document.getElementById('returnToMenuBtn').addEventListener('click', () => {
        // Navigate back to search tab
        document.getElementById('navSearch').click();
    });
}

// Show the multiplayer section
function showMultiplayerSection() {
    // Create multiplayer section if it doesn't exist
    if (!document.getElementById('multiplayerSection')) {
        createMultiplayerSection();
        addMultiplayerStyles();
    }
    
    // Show the section
    document.getElementById('multiplayerSection').classList.add('active');
    
    // Update connection status
    updateConnectionStatus();
    
    // Check for active games
    checkActiveGames();
}

// Update Firebase connection status
function updateConnectionStatus() {
    const statusElement = document.getElementById('connectionStatus');
    
    if (statusElement) {
        if (currentUser) {
            statusElement.innerHTML = `
                <p style="color: #4CAF50;"><span class="player-status online"></span> Connected as: ${getDisplayName()}</p>
            `;
        } else {
            statusElement.innerHTML = `
                <p style="color: #F44336;"><span class="player-status offline"></span> Not signed in. <a href="#" id="signInForMultiplayerLink">Sign in</a> for best experience.</p>
            `;
            
            // Add sign in link functionality
            document.getElementById('signInForMultiplayerLink').addEventListener('click', () => {
                showAuthModal();
            });
        }
    }
}

// Generate a random 6-digit game code
function generateGameCode() {
    return Math.floor(100000 + Math.random() * 900000).toString();
}

// Create a new multiplayer game
function createNewGame() {
    const playerName = document.getElementById('gameNameInput').value.trim();
    if (!playerName) {
        showNotification('Please enter your name', 'error');
        return;
    }
    
    // Get selected difficulty
    const difficultyBtn = document.querySelector('#mpDifficultySelection .quiz-type-button.active');
    const difficulty = difficultyBtn ? difficultyBtn.dataset.type : 'medium';
    
    // Generate a game code
    const gameCode = generateGameCode();
    
    // Create game in Firebase
    const gamesRef = ref(db, 'multiplayer_games');
    const newGameRef = push(gamesRef);
    
    // Get player ID
    const playerId = currentUser ? currentUser.uid : getOrCreateAnonymousId();
    
    // Save game info
    set(newGameRef, {
        gameCode: gameCode,
        status: 'waiting',
        createdAt: new Date().toISOString(),
        difficulty: difficulty,
        host: {
            id: playerId,
            name: playerName,
            score: 0,
            status: 'waiting'
        },
        currentQuestion: 0,
        questions: []
    }).then(() => {
        competitionRoomId = newGameRef.key;
        playerRole = 'host';
        
        // Show waiting room
        document.getElementById('multiplayerInfo').style.display = 'none';
        document.getElementById('waitingRoomContainer').style.display = 'block';
        document.getElementById('gameCodeDisplay').textContent = gameCode;
        
        // Set up Firebase listener to wait for opponent
        const gameRef = ref(db, `multiplayer_games/${competitionRoomId}`);
        const unsubscribe = onValue(gameRef, (snapshot) => {
            const gameData = snapshot.val();
            
            if (gameData && gameData.guest && gameData.status === 'ready') {
                unsubscribe(); // Stop listening once opponent has joined
                competitorData = gameData.guest;
                
                // Pre-fetch questions
                fetchCompetitionQuestions(gameData.difficulty).then(() => {
                    // Start competition when questions are ready
                    startCompetition(gameData);
                });
            }
        });
        
        waitingForOpponent = true;
    }).catch(error => {
        console.error('Error creating game:', error);
        showNotification('Failed to create game', 'error');
    });
}

// Join an existing game
function joinGame() {
    const playerName = document.getElementById('joinNameInput').value.trim();
    const gameCode = document.getElementById('gameCodeInput').value.trim();
    
    if (!playerName) {
        showNotification('Please enter your name', 'error');
        return;
    }
    
    if (!gameCode || gameCode.length !== 6) {
        showNotification('Please enter a valid 6-digit game code', 'error');
        return;
    }
    
    // Find game with matching code
    const gamesRef = ref(db, 'multiplayer_games');
    const gameQuery = query(gamesRef, orderByChild('gameCode'), equalTo(gameCode));
    
    get(gameQuery).then((snapshot) => {
        if (!snapshot.exists()) {
            showNotification('Game not found with that code', 'error');
            return;
        }
        
        // Get the game data
        let gameKey = null;
        let gameData = null;
        
        snapshot.forEach((childSnapshot) => {
            gameKey = childSnapshot.key;
            gameData = childSnapshot.val();
        });
        
        if (!gameKey || !gameData) {
            showNotification('Error finding game', 'error');
            return;
        }
        
        // Check game status
        if (gameData.status !== 'waiting') {
            showNotification('This game is no longer accepting players', 'error');
            return;
        }
        
        // Get player ID
        const playerId = currentUser ? currentUser.uid : getOrCreateAnonymousId();
        
        // Join the game
        const gameRef = ref(db, `multiplayer_games/${gameKey}`);
        
        update(gameRef, {
            status: 'ready',
            guest: {
                id: playerId,
                name: playerName,
                score: 0,
                status: 'ready'
            }
        }).then(() => {
            competitionRoomId = gameKey;
            playerRole = 'guest';
            competitorData = gameData.host;
            
            // Show waiting message
            document.getElementById('multiplayerInfo').style.display = 'none';
            document.getElementById('waitingRoomContainer').style.display = 'block';
            document.getElementById('waitingMessage').textContent = 'Game found! Preparing competition...';
            document.getElementById('gameCodeDisplay').textContent = gameCode;
            document.getElementById('copyGameCodeBtn').style.display = 'none';
            
            // Fetch questions and start the game
            fetchCompetitionQuestions(gameData.difficulty).then(() => {
                startCompetition(gameData);
            });
        }).catch(error => {
            console.error('Error joining game:', error);
            showNotification('Failed to join game', 'error');
        });
    }).catch(error => {
        console.error('Error searching for game:', error);
        showNotification('Error searching for game', 'error');
    });
}

// Cancel waiting for opponent
function cancelWaiting() {
    if (competitionRoomId && waitingForOpponent) {
        // Remove game from Firebase
        const gameRef = ref(db, `multiplayer_games/${competitionRoomId}`);
        remove(gameRef).then(() => {
            // Reset state
            competitionRoomId = null;
            playerRole = null;
            competitorData = null;
            waitingForOpponent = false;
            
            // Show multiplayer options again
            document.getElementById('waitingRoomContainer').style.display = 'none';
            document.getElementById('multiplayerInfo').style.display = 'block';
            
            showNotification('Game cancelled', 'success');
        }).catch(error => {
            console.error('Error cancelling game:', error);
            showNotification('Error cancelling game', 'error');
        });
    }
}

// Check for active games
function checkActiveGames() {
    if (!currentUser) {
        // No active games for anonymous users
        return;
    }
    
    const playerId = currentUser.uid;
    const gamesRef = ref(db, 'multiplayer_games');
    
    // Query for games where this player is host or guest
    const hostQuery = query(gamesRef, orderByChild('host/id'), equalTo(playerId));
    const guestQuery = query(gamesRef, orderByChild('guest/id'), equalTo(playerId));
    
    Promise.all([get(hostQuery), get(guestQuery)]).then(([hostSnapshot, guestSnapshot]) => {
        const activeGames = [];
        
        // Process games where player is host
        hostSnapshot.forEach(childSnapshot => {
            const gameData = childSnapshot.val();
            if (gameData.status !== 'completed') {
                activeGames.push({
                    id: childSnapshot.key,
                    role: 'host',
                    opponent: gameData.guest ? gameData.guest.name : 'Waiting for opponent',
                    status: gameData.status,
                    gameCode: gameData.gameCode
                });
            }
        });
        
        // Process games where player is guest
        guestSnapshot.forEach(childSnapshot => {
            const gameData = childSnapshot.val();
            if (gameData.status !== 'completed') {
                activeGames.push({
                    id: childSnapshot.key,
                    role: 'guest',
                    opponent: gameData.host ? gameData.host.name : 'Unknown',
                    status: gameData.status,
                    gameCode: gameData.gameCode
                });
            }
        });
        
        // Display active games if there are any
        if (activeGames.length > 0) {
            displayActiveGames(activeGames);
        }
    }).catch(error => {
        console.error('Error checking active games:', error);
    });
}

// Display active games
function displayActiveGames(games) {
    const activeGamesContainer = document.getElementById('activeGamesContainer');
    const activeGamesList = document.getElementById('activeGamesList');
    
    if (activeGamesContainer && activeGamesList) {
        activeGamesList.innerHTML = '';
        
        games.forEach(game => {
            const gameElement = document.createElement('div');
            gameElement.className = 'active-game-item';
            
            // Format status text
            let statusText = '';
            let actionButton = '';
            
            if (game.status === 'waiting') {
                statusText = 'Waiting for opponent';
                actionButton = `<button class="button button-small" onclick="copyGameCode('${game.gameCode}')">Share Code</button>`;
            } else if (game.status === 'ready') {
                statusText = 'Ready to start';
                actionButton = `<button class="button button-small" onclick="resumeGame('${game.id}')">Resume Game</button>`;
            } else if (game.status === 'in_progress') {
                statusText = 'Game in progress';
                actionButton = `<button class="button button-small" onclick="resumeGame('${game.id}')">Resume Game</button>`;
            }
            
            gameElement.innerHTML = `
                <div>
                    <div class="active-game-opponent">vs ${game.opponent}</div>
                    <div class="active-game-status">${statusText} • Code: <span class="game-code">${game.gameCode}</span></div>
                </div>
                <div class="active-game-actions">
                    ${actionButton}
                    <button class="button button-small button-secondary" onclick="abandonGame('${game.id}')">Abandon</button>
                </div>
            `;
            
            activeGamesList.appendChild(gameElement);
        });
        
        activeGamesContainer.style.display = 'block';
    }
}

// Function to copy game code to clipboard
function copyGameCode(code) {
    copyToClipboard(code);
    showNotification('Game code copied to clipboard!', 'success');
}

// Function to resume an existing game
function resumeGame(gameId) {
    const gameRef = ref(db, `multiplayer_games/${gameId}`);
    
    get(gameRef).then((snapshot) => {
        if (snapshot.exists()) {
            const gameData = snapshot.val();
            
            // Set up the competition
            competitionRoomId = gameId;
            playerRole = gameData.host.id === currentUser.uid ? 'host' : 'guest';
            competitorData = playerRole === 'host' ? gameData.guest : gameData.host;
            
            // Pre-fetch questions if needed
            if (!competitionQuestions.length) {
                fetchCompetitionQuestions(gameData.difficulty).then(() => {
                    startCompetition(gameData);
                });
            } else {
                startCompetition(gameData);
            }
        } else {
            showNotification('Game not found', 'error');
        }
    }).catch(error => {
        console.error('Error resuming game:', error);
        showNotification('Error resuming game', 'error');
    });
}

// Function to abandon a game
function abandonGame(gameId) {
    if (confirm('Are you sure you want to abandon this game? This will forfeit the game.')) {
        const gameRef = ref(db, `multiplayer_games/${gameId}`);
        
        get(gameRef).then((snapshot) => {
            if (snapshot.exists()) {
                const gameData = snapshot.val();
                
                // Determine player role
                const isHost = gameData.host.id === currentUser.uid;
                const playerRole = isHost ? 'host' : 'guest';
                const opponentRole = isHost ? 'guest' : 'host';
                
                // Update game status based on state
                if (gameData.status === 'waiting') {
                    // If waiting, just delete the game
                    remove(gameRef).then(() => {
                        showNotification('Game cancelled', 'success');
                        checkActiveGames(); // Refresh the list
                    });
                } else {
                    // If game is in progress or ready, declare other player as winner
                    const updates = {
                        status: 'completed',
                        winner: opponentRole,
                        endedAt: new Date().toISOString()
                    };
                    
                    // Update player status to show they forfeited
                    updates[`${playerRole}/status`] = 'forfeited';
                    
                    update(gameRef, updates).then(() => {
                        showNotification('Game forfeited', 'success');
                        checkActiveGames(); // Refresh the list
                    });
                }
            } else {
                showNotification('Game not found', 'error');
            }
        }).catch(error => {
            console.error('Error abandoning game:', error);
            showNotification('Error abandoning game', 'error');
        });
    }
}

// Fetch questions for competition
async function fetchCompetitionQuestions(difficulty) {
    try {
        // Get approved phrases from Firebase
        const approvedPhrasesRef = ref(db, 'approved_phrases');
        const snapshot = await get(approvedPhrasesRef);
        
        if (!snapshot.exists() || snapshot.size === 0) {
            throw new Error('No approved phrases found');
        }
        
        // Process data
        const allPhrases = [];
        snapshot.forEach(childSnapshot => {
            const phraseData = childSnapshot.val();
            if (phraseData.phrase && phraseData.translation) {
                allPhrases.push(phraseData);
            }
        });
        
        if (allPhrases.length < 4) {
            throw new Error('Not enough phrases for competition');
        }
        
        // Shuffle phrases
        const shuffledPhrases = shuffleArray(allPhrases);
        
        // Determine number of questions based on difficulty
        let questionCount;
        switch (difficulty) {
            case 'easy':
                questionCount = 5;
                break;
            case 'hard':
                questionCount = 15;
                break;
            case 'medium':
            default:
                questionCount = 10;
                break;
        }
        
        // Make sure we have enough phrases
        questionCount = Math.min(questionCount, allPhrases.length);
        
        // Prepare competition questions
        competitionQuestions = [];
        
        for (let i = 0; i < questionCount; i++) {
            const isEnglishToKunama = Math.random() > 0.5;
            
            // Get this phrase
            const phraseData = shuffledPhrases[i];
            
            // Create a question
            const question = {
                prompt: isEnglishToKunama ? phraseData.phrase : phraseData.translation,
                correctAnswer: isEnglishToKunama ? phraseData.translation : phraseData.phrase,
                isEnglishToKunama: isEnglishToKunama,
                options: []
            };
            
            // Create options (1 correct + 3 incorrect)
            let options = [question.correctAnswer];
            
            // Add incorrect options from other phrases
            let attemptCount = 0;
            while (options.length < 4 && attemptCount < 20) {
                attemptCount++;
                const randomIndex = Math.floor(Math.random() * allPhrases.length);
                const randomOption = isEnglishToKunama ? 
                    allPhrases[randomIndex].translation : 
                    allPhrases[randomIndex].phrase;
                
                // Make sure we don't add duplicates
                if (!options.includes(randomOption) && randomOption !== question.correctAnswer) {
                    options.push(randomOption);
                }
            }
            
            // Shuffle options
            question.options = shuffleArray(options);
            
            competitionQuestions.push(question);
        }
        
        // Save questions to Firebase for consistency between players
        if (playerRole === 'host' && competitionRoomId) {
            const questionsRef = ref(db, `multiplayer_games/${competitionRoomId}/questions`);
            set(questionsRef, competitionQuestions);
        }
        
        return competitionQuestions;
    } catch (error) {
        console.error('Error fetching competition questions:', error);
        showNotification('Error preparing competition', 'error');
        throw error;
    }
}

// Start the competition
function startCompetition(gameData) {
    // Hide waiting room
    document.getElementById('waitingRoomContainer').style.display = 'none';
    
    // Set up competition container
    const competitionContainer = document.getElementById('competitionContainer');
    competitionContainer.style.display = 'block';
    
    // Set player info
    const player1Info = document.getElementById('player1Info');
    const player2Info = document.getElementById('player2Info');
    
    if (playerRole === 'host') {
        player1Info.querySelector('.player-name').textContent = gameData.host.name + ' (You)';
        player2Info.querySelector('.player-name').textContent = gameData.guest.name;
    } else {
        player1Info.querySelector('.player-name').textContent = gameData.host.name;
        player2Info.querySelector('.player-name').textContent = gameData.guest.name + ' (You)';
    }
    
    player1Info.querySelector('.player-score').textContent = '0 points';
    player2Info.querySelector('.player-score').textContent = '0 points';
    
    // Update game status in Firebase if needed
    if (gameData.status !== 'in_progress') {
        const gameRef = ref(db, `multiplayer_games/${competitionRoomId}`);
        update(gameRef, {
            status: 'in_progress',
            startedAt: new Date().toISOString()
        });
    }
    
    // Load questions from Firebase if we're joining a game in progress
    if (playerRole === 'guest' && !competitionQuestions.length && gameData.questions) {
        competitionQuestions = gameData.questions;
    }
    
    // Start with the first question
    showCompetitionQuestion(0);
    
    // Set up a listener for opponent's actions
    setupCompetitionListeners();
}

// Show a competition question
function showCompetitionQuestion(questionIndex) {
    // Ensure we have questions and index is valid
    if (!competitionQuestions.length || questionIndex >= competitionQuestions.length) {
        console.error('Invalid question index or no questions available');
        return;
    }
    
    const question = competitionQuestions[questionIndex];
    const questionNumber = document.getElementById('questionNumber');
    const questionType = document.getElementById('mpQuestionType');
    const questionPrompt = document.getElementById('mpQuestionPrompt');
    const quizOptions = document.getElementById('mpQuizOptions');
    const questionFeedback = document.getElementById('mpQuestionFeedback');
    
    // Update question number
    questionNumber.textContent = `Question ${questionIndex + 1} of ${competitionQuestions.length}`;
    
    // Update question type
    questionType.textContent = question.isEnglishToKunama ? 'English to Kunama' : 'Kunama to English';
    
    // Update question prompt
    questionPrompt.textContent = `Translation for: ${question.prompt}`;
    
    // Clear previous options and feedback
    quizOptions.innerHTML = '';
    questionFeedback.style.display = 'none';
    
    // Add options
    question.options.forEach((option, index) => {
        const optionElement = document.createElement('div');
        optionElement.className = 'mp-option';
        optionElement.textContent = option;
        optionElement.dataset.index = index;
        
        // Add click handler to select option
        optionElement.addEventListener('click', () => {
            selectCompetitionAnswer(questionIndex, index);
        });
        
        quizOptions.appendChild(optionElement);
    });
    
    // Update current question in Firebase
    const gameRef = ref(db, `multiplayer_games/${competitionRoomId}`);
    update(gameRef, {
        currentQuestion: questionIndex
    });
    
    // Start question timer
    startCompetitionTimer();
}

// Select an answer in competition
function selectCompetitionAnswer(questionIndex, optionIndex) {
    // Get the question and selected option
    const question = competitionQuestions[questionIndex];
    const selectedOption = question.options[optionIndex];
    const isCorrect = selectedOption === question.correctAnswer;
    
    // Disable all options
    const options = document.querySelectorAll('.mp-option');
    options.forEach(option => {
        option.style.pointerEvents = 'none';
    });
    
    // Highlight selected option
    const selectedElement = options[optionIndex];
    selectedElement.classList.add(isCorrect ? 'correct' : 'incorrect');
    
    // Show feedback
    const feedbackElement = document.getElementById('mpQuestionFeedback');
    feedbackElement.textContent = isCorrect ? '✅ Correct!' : `❌ Incorrect. The correct answer is: ${question.correctAnswer}`;
    feedbackElement.className = isCorrect ? 'correct' : 'incorrect';
    feedbackElement.style.display = 'block';
    
    // Update score if correct
    if (isCorrect) {
        // Calculate points based on remaining time
        const remainingTime = parseInt(document.getElementById('mpTimerValue').textContent);
        const timeBonus = Math.max(0, remainingTime) / 5; // 0.2 points per second remaining
        const points = 10 + Math.round(timeBonus);
        
        // Update score in Firebase
        const playerPath = playerRole === 'host' ? 'host' : 'guest';
        const gameRef = ref(db, `multiplayer_games/${competitionRoomId}`);
        
        get(gameRef).then(snapshot => {
            if (snapshot.exists()) {
                const gameData = snapshot.val();
                const currentScore = gameData[playerPath].score || 0;
                const newScore = currentScore + points;
                
                const updates = {};
                updates[`${playerPath}/score`] = newScore;
                updates[`${playerPath}/lastAnswer`] = {
                    questionIndex,
                    optionIndex,
                    isCorrect,
                    timestamp: new Date().toISOString()
                };
                
                update(gameRef, updates).then(() => {
                    // Update local UI
                    const playerInfo = playerRole === 'host' ? 
                        document.getElementById('player1Info') : 
                        document.getElementById('player2Info');
                    
                    playerInfo.querySelector('.player-score').textContent = `${newScore} points`;
                });
            }
        });
    } else {
        // Just record the wrong answer
        const playerPath = playerRole === 'host' ? 'host' : 'guest';
        const gameRef = ref(db, `multiplayer_games/${competitionRoomId}`);
        
        const updates = {};
        updates[`${playerPath}/lastAnswer`] = {
            questionIndex,
            optionIndex,
            isCorrect,
            timestamp: new Date().toISOString()
        };
        
        update(gameRef, updates);
    }
    
    // Clear timer
    if (competitionTimer) {
        clearInterval(competitionTimer);
    }
    
    // Move to next question after a delay
    setTimeout(() => {
        const nextQuestionIndex = questionIndex + 1;
        
        if (nextQuestionIndex < competitionQuestions.length) {
            showCompetitionQuestion(nextQuestionIndex);
        } else {
            endCompetition();
        }
    }, 2000);
}

// Start competition timer
function startCompetitionTimer() {
    // Clear any existing timer
    if (competitionTimer) {
        clearInterval(competitionTimer);
    }
    
    // Set initial time based on difficulty
    let timeLeft;
    const gameRef = ref(db, `multiplayer_games/${competitionRoomId}`);
    
    get(gameRef).then(snapshot => {
        if (snapshot.exists()) {
            const gameData = snapshot.val();
            switch (gameData.difficulty) {
                case 'easy':
                    timeLeft = 20;
                    break;
                case 'hard':
                    timeLeft = 10;
                    break;
                case 'medium':
                default:
                    timeLeft = 15;
                    break;
            }
            
            const timerElement = document.getElementById('mpTimerValue');
            timerElement.textContent = timeLeft;
            
            // Start countdown
            competitionTimer = setInterval(() => {
                timeLeft--;
                timerElement.textContent = timeLeft;
                
                // Add warning class when time is running out
                if (timeLeft <= 5) {
                    timerElement.style.color = '#F44336';
                } else {
                    timerElement.style.color = '';
                }
                
                // Time's up
                if (timeLeft <= 0) {
                    clearInterval(competitionTimer);
                    handleTimedOut();
                }
            }, 1000);
        }
    });
}

// Handle time running out
function handleTimedOut() {
    // Get current question index
    const gameRef = ref(db, `multiplayer_games/${competitionRoomId}`);
    
    get(gameRef).then(snapshot => {
        if (snapshot.exists()) {
            const gameData = snapshot.val();
            const currentQuestionIndex = gameData.currentQuestion;
            
            // Record timeout
            const playerPath = playerRole === 'host' ? 'host' : 'guest';
            const updates = {};
            updates[`${playerPath}/lastAnswer`] = {
                questionIndex: currentQuestionIndex,
                timedOut: true,
                isCorrect: false,
                timestamp: new Date().toISOString()
            };
            
            update(gameRef, updates).then(() => {
                // Show feedback
                const feedbackElement = document.getElementById('mpQuestionFeedback');
                feedbackElement.textContent = "⏱️ Time's up!";
                feedbackElement.className = 'incorrect';
                feedbackElement.style.display = 'block';
                
                // Disable all options
                const options = document.querySelectorAll('.mp-option');
                options.forEach(option => {
                    option.style.pointerEvents = 'none';
                });
                
                // Move to next question after delay
                setTimeout(() => {
                    const nextQuestionIndex = currentQuestionIndex + 1;
                    
                    if (nextQuestionIndex < competitionQuestions.length) {
                        showCompetitionQuestion(nextQuestionIndex);
                    } else {
                        endCompetition();
                    }
                }, 2000);
            });
        }
    });
}

// Set up listeners for opponent's actions
function setupCompetitionListeners() {
    const gameRef = ref(db, `multiplayer_games/${competitionRoomId}`);
    
    // Listen for opponent's answers
    onValue(gameRef, (snapshot) => {
        if (snapshot.exists()) {
            const gameData = snapshot.val();
            const opponentRole = playerRole === 'host' ? 'guest' : 'host';
            
            // Check if opponent has a new answer
            if (gameData[opponentRole] && gameData[opponentRole].lastAnswer) {
                const opponentAnswer = gameData[opponentRole].lastAnswer;
                
                // Update opponent's score display
                const opponentInfo = playerRole === 'host' ? 
                    document.getElementById('player2Info') : 
                    document.getElementById('player1Info');
                
                opponentInfo.querySelector('.player-score').textContent = `${gameData[opponentRole].score || 0} points`;
                
                // If both players have answered the last question, move to the next question
                if (opponentAnswer.questionIndex === gameData.currentQuestion) {
                    const playerAnswer = gameData[playerRole]?.lastAnswer;
                    
                    if (playerAnswer && playerAnswer.questionIndex === gameData.currentQuestion) {
                        // Both players have answered, check if we're at the last question
                        const nextQuestionIndex = gameData.currentQuestion + 1;
                        
                        if (nextQuestionIndex >= competitionQuestions.length) {
                            endCompetition();
                        }
                    }
                }
            }
            
            // Check if game is completed
            if (gameData.status === 'completed') {
                showCompetitionResults(gameData);
            }
        }
    });
}

// End the competition
function endCompetition() {
    // Get final scores
    const gameRef = ref(db, `multiplayer_games/${competitionRoomId}`);
    
    get(gameRef).then(snapshot => {
        if (snapshot.exists()) {
            const gameData = snapshot.val();
            
            // Determine winner
            const hostScore = gameData.host.score || 0;
            const guestScore = gameData.guest.score || 0;
            
            let winner;
            if (hostScore > guestScore) {
                winner = 'host';
            } else if (guestScore > hostScore) {
                winner = 'guest';
            } else {
                winner = 'tie';
            }
            
            // Update game status
            update(gameRef, {
                status: 'completed',
                winner: winner,
                endedAt: new Date().toISOString()
            }).then(() => {
                showCompetitionResults(gameData);
            });
        }
    });
}

// Show competition results
function showCompetitionResults(gameData) {
    // Hide question container
    document.getElementById('competitionQuestion').style.display = 'none';
    document.getElementById('competitionTimer').style.display = 'none';
    
    // Show results container
    const resultsContainer = document.getElementById('competitionResults');
    const winnerDisplay = document.getElementById('winnerDisplay');
    const finalScores = document.getElementById('finalScores');
    
    // Determine winner and scores
    const hostScore = gameData.host.score || 0;
    const guestScore = gameData.guest.score || 0;
    
    let winnerText = '';
    if (hostScore > guestScore) {
        winnerText = playerRole === 'host' ? 'You won! 🎉' : `${gameData.host.name} won!`;
    } else if (guestScore > hostScore) {
        winnerText = playerRole === 'guest' ? 'You won! 🎉' : `${gameData.guest.name} won!`;
    } else {
        winnerText = 'It\'s a tie!';
    }
    
    winnerDisplay.textContent = winnerText;
    
    // Show final scores
    finalScores.innerHTML = `
        <div style="font-size: 18px; margin: 10px 0;">
            <div>${gameData.host.name}: ${hostScore} points</div>
            <div>${gameData.guest.name}: ${guestScore} points</div>
        </div>
    `;
    
    // Award points to winner if it's the current player
    if ((playerRole === 'host' && hostScore > guestScore) || 
        (playerRole === 'guest' && guestScore > hostScore)) {
        // Add points to user's account
        addPoints(50, "Won Multiplayer Competition");
        
        // Check for achievements
        if (!hasAchievement("multiplayer_win")) {
            unlockAchievement("multiplayer_win");
        }
    }
    
    // Show results container
    resultsContainer.style.display = 'block';
}

// Helper function to get or create anonymous ID
function getOrCreateAnonymousId() {
    let anonymousId = localStorage.getItem('kunama_anonymous_id');
    if (!anonymousId) {
        anonymousId = 'anon_' + Math.random().toString(36).substr(2, 9);
        localStorage.setItem('kunama_anonymous_id', anonymousId);
    }
    return anonymousId;
}

// Add the multiplayer achievement to the achievements list
function addMultiplayerAchievements() {
    // Check if achievements array is defined
    if (typeof achievements !== 'undefined') {
        // Add multiplayer achievements if they don't exist
        if (!achievements.find(a => a.id === 'multiplayer_win')) {
            achievements.push({
                id: "multiplayer_win",
                icon: "🏆",
                title: "Champion",
                description: "Win a multiplayer competition",
                condition: "Win a competition",
                unlockedAt: null
            });
        }
        
        if (!achievements.find(a => a.id === 'multiplayer_streak')) {
            achievements.push({
                id: "multiplayer_streak",
                icon: "🔥",
                title: "Winning Streak",
                description: "Win 3 multiplayer competitions in a row",
                condition: "3-win streak",
                unlockedAt: null
            });
        }
    }
}

// Main initialization function
// Fixed: Use a single window.onload handler that properly combines initialization functions
window.onload = function() {
    try {
        // Create a placeholder anonymous user ID for app functionality
        if (!localStorage.getItem("kunama_contributor_id")) {
            const contributorId = "anon_" + Math.random().toString(36).substr(2, 9);
            localStorage.setItem("kunama_contributor_id", contributorId);
        }
        
        // Setup navigation
        setupNavigation();
        
        // Setup quiz functionality
        window.startQuiz = startQuiz;
        window.checkAnswer = checkAnswer;
        window.nextQuestion = nextQuestion;
        window.setDifficulty = setDifficulty;
        
        // Load high score for quiz
        highScore = localStorage.getItem('kunamaQuizHighScore') || 0;
        document.getElementById('highScoreValue').innerText = `${highScore}%`;
        
        // Set default quiz difficulty
        setDifficulty('medium');
        
        // Setup base functionality
        setupEventListeners();
        updateProgressBar();
        setupCharacterCounters();
        setupAutoSave();
        setupDarkMode();
        
        // Fetch data
        fetchRecentTranslations();
        fetchContributorLeaderboard();
        
        // Setup authentication
        setupAuthentication();
        
        // Initialize enhanced features
        initEnhancedFeatures();
        
        // Add multiplayer functionality
        setTimeout(() => {
            addMultiplayerTab();
            addMultiplayerAchievements();
            
            // Expose multiplayer functions to window for button click handlers
            window.copyGameCode = copyGameCode;
            window.resumeGame = resumeGame;
            window.abandonGame = abandonGame;
        }, 300);
        
        // Load available voices for TTS (some browsers need this)
        if ('speechSynthesis' in window) {
            window.speechSynthesis.onvoiceschanged = function() {
                // Voices loaded
                const voices = window.speechSynthesis.getVoices();
                console.log(`Loaded ${voices.length} voices for speech synthesis`);
            };
        }
        
        console.log("Application initialization completed successfully.");
    } catch (error) {
        console.error("Error during application initialization:", error);
        showNotification("There was a problem initializing the application. Please refresh the page.", "error");
    }
};
    </script>
</body>
</html>
